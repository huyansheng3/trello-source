function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { Component } from 'react';
import Observer from '@researchgate/react-intersection-observer';
import PropTypes from 'prop-types';
import { polyfill } from 'react-lifecycles-compat';
import { computeRootMargin } from './utils';

var Sentinel = function (_Component) {
    _inherits(Sentinel, _Component);

    function Sentinel(props) {
        _classCallCheck(this, Sentinel);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props));

        _this.setRootElement = function (rootElement) {
            _this.setState({ rootElement: rootElement });
        };

        _this.state = {
            rootElement: undefined,
            rootMargin: computeRootMargin(props)
        };

        _this.target = React.createElement('span', { style: { height: 1, width: 1, display: 'block' } });

        props.setRef(_this.setRootElement);
        return _this;
    }

    Sentinel.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
        var threshold = _ref.threshold,
            axis = _ref.axis;

        var newState = null;
        if (threshold !== prevState.threshold || axis !== prevState.axis) {
            newState = {
                threshold: threshold,
                axis: axis,
                rootMargin: computeRootMargin({ threshold: threshold, axis: axis })
            };
        }
        return newState;
    };

    Sentinel.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, _ref2) {
        var rootMargin = _ref2.rootMargin,
            rootElement = _ref2.rootElement;
        var _state = this.state,
            currentRootMargin = _state.rootMargin,
            currentRootElement = _state.rootElement;
        // When the rootMargin stays the same but the sentinel is repositioned, it can fall within
        // its threshold prematurely. In this case we don't get any update from the Observer instance.
        // We need to guarantee an update, and re-observing is a cheap way to accomplish this.

        if (currentRootMargin === rootMargin && currentRootElement === rootElement) {
            this.element.unobserve();
            this.element.observe();
            return false;
        }
        return true;
    };

    Sentinel.prototype.render = function render() {
        var _this2 = this;

        var onChange = this.props.onChange;
        var _state2 = this.state,
            rootElement = _state2.rootElement,
            rootMargin = _state2.rootMargin;


        return React.createElement(
            Observer,
            {
                ref: function ref(node) {
                    _this2.element = node;
                },
                disabled: typeof rootElement === 'undefined',
                root: rootElement,
                rootMargin: rootMargin,
                onChange: onChange
            },
            this.target
        );
    };

    return Sentinel;
}(Component);

// Polyfill your component so the new lifecycles will work with older versions of React:


process.env.NODE_ENV !== "production" ? Sentinel.propTypes = {
    axis: PropTypes.oneOf(['x', 'y']).isRequired,
    threshold: PropTypes.string.isRequired,
    setRef: PropTypes.func.isRequired,
    onChange: PropTypes.func.isRequired
} : void 0;
polyfill(Sentinel);

export default Sentinel;