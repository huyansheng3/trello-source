function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import { polyfill } from 'react-lifecycles-compat';
import warning from 'warning';
import Sentinel from './Sentinel';
import { getItemCount, computeSize } from './utils';

var AXIS_CSS_MAP = { x: 'overflowX', y: 'overflowY' };

var List = function (_PureComponent) {
    _inherits(List, _PureComponent);

    function List() {
        var _temp, _this, _ret;

        _classCallCheck(this, List);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this.state = {
            size: 0
        }, _this.setRef = function (callback) {
            var prevRootNode = void 0;
            _this.setRootNode = function (node) {
                if (node !== prevRootNode) {
                    prevRootNode = node;
                    var overflow = window.getComputedStyle(node)[AXIS_CSS_MAP[_this.props.axis]];
                    callback(['auto', 'scroll', 'overlay'].indexOf(overflow) !== -1 ? node : null);
                }
            };
        }, _this.handleUpdate = function (_ref) {
            var isIntersecting = _ref.isIntersecting;
            var _this$props = _this.props,
                awaitMore = _this$props.awaitMore,
                onIntersection = _this$props.onIntersection;
            var _this$state = _this.state,
                size = _this$state.size,
                itemCount = _this$state.itemCount,
                pageSize = _this$state.pageSize;


            if (!_this.prematureIntersectionChecked) {
                _this.prematureIntersectionChecked = true;
                warning(!isIntersecting, 'ReactIntersectionList: the sentinel detected a viewport with a bigger size than the size of its items. ' + 'This could lead to detrimental behavior, e.g.: triggering more than one onIntersection callback at the start.\n' + 'To prevent this, use either a bigger `pageSize` value or avoid using the prop awaitMore initially.');
            }

            if (isIntersecting) {
                var nextSize = computeSize(size + pageSize, itemCount);
                if (size !== nextSize) {
                    _this.setState({ size: nextSize });
                }
                if (onIntersection && (!awaitMore || _this.awaitIntersection)) {
                    if (_this.awaitIntersection) {
                        _this.awaitIntersection = false;
                    }
                    onIntersection(nextSize, pageSize);
                }
            }
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    List.getDerivedStateFromProps = function getDerivedStateFromProps(_ref2, prevState) {
        var pageSize = _ref2.pageSize,
            props = _objectWithoutProperties(_ref2, ['pageSize']);

        var itemCount = getItemCount(props, true);

        var newSize = void 0;
        if (prevState.size === 0) {
            newSize = pageSize;
        } else {
            if (prevState.itemCount < itemCount) {
                newSize = prevState.size + pageSize;
            } else {
                newSize = prevState.size + -(prevState.pageSize - pageSize);
            }
        }

        return {
            pageSize: pageSize,
            itemCount: itemCount,
            size: computeSize(newSize, itemCount)
        };
    };

    List.prototype.componentDidMount = function componentDidMount() {
        this.prematureIntersectionChecked = this.state.size === 0;
    };

    List.prototype.getItemRenderer = function getItemRenderer() {
        var _props = this.props,
            children = _props.children,
            renderItem = _props.renderItem;

        var hasChildren = typeof children !== 'undefined';
        var hasRender = typeof renderItem !== 'undefined';

        warning(!(hasChildren && hasRender), 'ReactIntersectionList: cannot use children and renderItem props as render function at the same time.');

        if (hasChildren) {
            return children;
        }

        return hasRender ? renderItem : function (index, key) {
            return React.createElement(
                'div',
                { key: key },
                index
            );
        };
    };

    List.prototype.renderItems = function renderItems() {
        var _this2 = this;

        var _props2 = this.props,
            awaitMore = _props2.awaitMore,
            axis = _props2.axis,
            initialIndex = _props2.initialIndex,
            itemsRenderer = _props2.itemsRenderer,
            threshold = _props2.threshold;
        var _state = this.state,
            size = _state.size,
            itemCount = _state.itemCount;

        var itemRenderer = this.getItemRenderer();
        var items = [];

        for (var i = 0; i < size; ++i) {
            items.push(itemRenderer(initialIndex + i, i));
        }

        var sentinel = void 0;
        if (size < itemCount || awaitMore) {
            sentinel = React.createElement(Sentinel, {
                key: 'sentinel',
                threshold: threshold,
                axis: axis,
                setRef: this.setRef,
                onChange: this.handleUpdate
            });
            items.push(sentinel);

            if (awaitMore) {
                this.awaitIntersection = true;
            }
        }

        return itemsRenderer(items, function (node) {
            if (node && sentinel) {
                _this2.setRootNode(node);
            }
        });
    };

    List.prototype.render = function render() {
        return this.renderItems();
    };

    return List;
}(PureComponent);

// Polyfill your component so the new lifecycles will work with older versions of React:


List.defaultProps = {
    axis: 'y',
    initialIndex: 0,
    itemsRenderer: function itemsRenderer(items, ref) {
        return React.createElement(
            'div',
            { ref: ref },
            items
        );
    },
    pageSize: 10,
    threshold: '100px'
};
process.env.NODE_ENV !== "production" ? List.propTypes = {
    awaitMore: PropTypes.bool,
    axis: PropTypes.oneOf(['x', 'y']),
    children: PropTypes.func,
    initialIndex: PropTypes.number,
    items: function items(props, propName) {
        var object = props[propName];
        if (object != null && !(Array.isArray(object) || typeof object[Symbol.iterator] === 'function')) {
            return new Error('`' + propName + '` must be of type Array or a native type implementing the iterable interface');
        }
        return undefined;
    },

    itemCount: PropTypes.number,
    itemsRenderer: PropTypes.func,
    onIntersection: PropTypes.func,
    pageSize: PropTypes.number,
    renderItem: PropTypes.func,
    threshold: PropTypes.string
} : void 0;
polyfill(List);

export default List;