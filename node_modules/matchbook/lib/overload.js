"use strict";

var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) { _arr.push(_step.value); if (i && _arr.length === i) break; } return _arr; } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } };

var compile = require("./compile");
var AnyPattern = require("./any-pattern");

module.exports = function (matchSetup) {
  if (typeof matchSetup !== "function") {
    throw new Error("Pass a function to pattern.");
  }
  var patterns = [];

  var matchImplementation = function matchImplementation(pattern, implementation) {
    if (arguments.length === 0) {
      throw new Error("Cannot call match without arguments.");
    }
    if (arguments.length === 1) {
      implementation = pattern;
      pattern = AnyPattern;
    }
    if (typeof implementation !== "function") {
      throw new Error("Final argument to match must be a function implementation.");
    }
    patterns.push([compile(pattern), implementation]);
  };

  matchSetup(function () {
    matchImplementation.apply(this, arguments);
  });
  matchImplementation = function () {
    throw new Error("Cannot call match outside of a pattern invocation.");
  };

  return function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    for (var _iterator = patterns, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var _ref2 = _slicedToArray(_ref, 2);

      var pattern = _ref2[0];
      var implementation = _ref2[1];

      if (pattern(args)) {
        return implementation.apply(this, args);
      }
    }
    throw new Error("No matching pattern");
  };
};