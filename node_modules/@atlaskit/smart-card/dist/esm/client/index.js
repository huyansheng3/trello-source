import _regeneratorRuntime from "@babel/runtime/regenerator";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import DataLoader from 'dataloader';
import retry from 'async-retry';
import * as api from './api';
import { APIError } from './errors';
import { getResolverUrl } from './utils/environments'; // @ts-ignore

import BottleneckLight from 'bottleneck/light';
var Bottleneck = BottleneckLight;
import { isSuccessfulResponse, isErrorResponse } from './types/responses';
var MAX_BATCH_SIZE = 50;
var MIN_TIME_BETWEEN_BATCHES = 250;

var CardClient = /*#__PURE__*/function () {
  function CardClient(envKey) {
    _classCallCheck(this, CardClient);

    this.resolverUrl = getResolverUrl(envKey);
    this.loadersByDomain = {};
    this.retryConfig = {
      retries: 2
    };
    this.resolvedCache = {};
  }

  _createClass(CardClient, [{
    key: "batchResolve",
    value: function () {
      var _batchResolve = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(urls) {
        var deDuplicatedUrls, resolvedUrls, map, i, url, data;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                // De-duplicate requested URLs (see `this.createLoader` for more detail).
                deDuplicatedUrls = _toConsumableArray(new Set(urls));
                resolvedUrls = [];
                _context.prev = 2;
                _context.next = 5;
                return api.request('post', "".concat(this.resolverUrl, "/resolve/batch"), deDuplicatedUrls.map(function (resourceUrl) {
                  return {
                    resourceUrl: resourceUrl
                  };
                }));

              case 5:
                resolvedUrls = _context.sent;
                _context.next = 11;
                break;

              case 8:
                _context.prev = 8;
                _context.t0 = _context["catch"](2);
                // we make sure we return a valid dataloader response by creating an error
                // response for each url
                resolvedUrls = urls.map(function () {
                  var status = isErrorResponse(_context.t0) ? _context.t0.status : 500;
                  var errorResponse = {
                    status: status,
                    error: _context.t0
                  };
                  return errorResponse;
                });

              case 11:
                // Reduce into a map to make accessing faster and easier.
                map = {}; // NOTE: the batch endpoint returns the URLs in the same order they were given.

                for (i = 0; i < deDuplicatedUrls.length; ++i) {
                  url = deDuplicatedUrls[i];
                  data = resolvedUrls[i];
                  map[url] = data;
                } // Reconvert list back into the original order in which it was given to us.


                return _context.abrupt("return", urls.map(function (originalUrl) {
                  return map[originalUrl];
                }));

              case 14:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[2, 8]]);
      }));

      function batchResolve(_x) {
        return _batchResolve.apply(this, arguments);
      }

      return batchResolve;
    }()
  }, {
    key: "createLoader",
    value: function createLoader() {
      var _this = this;

      var limiter = new Bottleneck({
        minTime: MIN_TIME_BETWEEN_BATCHES
      });
      return new DataLoader( // We place all calls to `batchResolve` in a limiter so we don't send off several simultaneous batch requests.
      // This is for two reasons:
      //  1: we want to avoid getting rate limited upstream (eg: forge and other APIs)
      //  2: we want to avoid sending out heaps of requests from the client at once
      function (urls) {
        return limiter.schedule(function () {
          return _this.batchResolve(urls);
        });
      }, {
        maxBatchSize: MAX_BATCH_SIZE,
        // NOTE: we turn off DataLoader's cache because it doesn't work for our use-case. Consider the following:
        // - a smartlink to a restricted item is resolved to "forbidden" with a "request access button"
        // - the user clicks "request access", and then following the auth prompts and gets access
        // - the frontend now re-renders the smartlink, but due to DataLoader's caching, the previous "forbidden" state is
        //   because the smartlink's URL (which is the cache key) is exactly the same
        //
        // For this reason, we disable DataLoader's cache.
        // This means that URLs will not be de-duplicated by DataLoader, so we perform the de-duplication logic
        // ourselves in `this.batchResolve`.
        cache: false
      });
    }
  }, {
    key: "getLoader",
    value: function getLoader(hostname) {
      if (!this.loadersByDomain[hostname]) {
        this.loadersByDomain[hostname] = this.createLoader();
      }

      return this.loadersByDomain[hostname];
    }
  }, {
    key: "prefetchData",
    value: function () {
      var _prefetchData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(url) {
        var _this2 = this;

        var hostname, loader, response, retriedResponse;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                // 1. Queue the URL as part of a dataloader batch.
                hostname = new URL(url).hostname;
                loader = this.getLoader(hostname);
                _context3.next = 4;
                return loader.load(url);

              case 4:
                response = _context3.sent;

                if (!isSuccessfulResponse(response)) {
                  _context3.next = 9;
                  break;
                }

                return _context3.abrupt("return", response.body);

              case 9:
                _context3.prev = 9;
                _context3.next = 12;
                return retry( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
                  var _response;

                  return _regeneratorRuntime.wrap(function _callee2$(_context2) {
                    while (1) {
                      switch (_context2.prev = _context2.next) {
                        case 0:
                          if (_this2.resolvedCache[url]) {
                            _context2.next = 11;
                            break;
                          }

                          _context2.next = 3;
                          return loader.load(url);

                        case 3:
                          _response = _context2.sent;

                          if (!isSuccessfulResponse(_response)) {
                            _context2.next = 8;
                            break;
                          }

                          return _context2.abrupt("return", _response);

                        case 8:
                          throw new Error('Retry for URL failed');

                        case 9:
                          _context2.next = 12;
                          break;

                        case 11:
                          throw new Error('Retry unneeded - link has been resolved.');

                        case 12:
                        case "end":
                          return _context2.stop();
                      }
                    }
                  }, _callee2);
                })), this.retryConfig);

              case 12:
                retriedResponse = _context3.sent;
                return _context3.abrupt("return", retriedResponse.body);

              case 16:
                _context3.prev = 16;
                _context3.t0 = _context3["catch"](9);
                return _context3.abrupt("return", undefined);

              case 19:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[9, 16]]);
      }));

      function prefetchData(_x2) {
        return _prefetchData.apply(this, arguments);
      }

      return prefetchData;
    }()
  }, {
    key: "fetchData",
    value: function () {
      var _fetchData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(url) {
        var hostname, loader, response, errorType, errorMessage;
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                hostname = new URL(url).hostname;
                loader = this.getLoader(hostname);
                _context4.next = 4;
                return loader.load(url);

              case 4:
                response = _context4.sent;

                if (isSuccessfulResponse(response)) {
                  _context4.next = 23;
                  break;
                }

                if (!response.error) {
                  _context4.next = 20;
                  break;
                }

                errorType = response.error.type;
                errorMessage = response.error.message; // this means there was a network error and we fallback to blue link
                // without impacting SLO's

                if (!(response.error instanceof api.NetworkError)) {
                  _context4.next = 11;
                  break;
                }

                throw new APIError('fallback', hostname, errorMessage, errorType);

              case 11:
                _context4.t0 = errorType;
                _context4.next = _context4.t0 === 'ResolveBadRequestError' ? 14 : _context4.t0 === 'ResolveAuthError' ? 15 : _context4.t0 === 'ResolveUnsupportedError' ? 16 : _context4.t0 === 'ResolveFailedError' ? 17 : _context4.t0 === 'ResolveTimeoutError' ? 18 : _context4.t0 === 'InternalServerError' ? 19 : 20;
                break;

              case 14:
                throw new APIError('fallback', hostname, errorMessage, errorType);

              case 15:
                throw new APIError('auth', hostname, errorMessage, errorType);

              case 16:
                throw new APIError('fatal', hostname, errorMessage, errorType);

              case 17:
                throw new APIError('error', hostname, errorMessage, errorType);

              case 18:
                throw new APIError('error', hostname, errorMessage, errorType);

              case 19:
                throw new APIError('error', hostname, errorMessage, errorType);

              case 20:
                throw new APIError('fatal', hostname, response.toString(), 'UnexpectedError');

              case 23:
                // Set a flag in the `resolvedCache` for this URL. The intent of this is
                // to ensure that the exponential backoff method in `prefetchData` does
                // not continue to retry fetching for this URL, especially if it was previously
                // in a failed state. Note: this scenario only occurs on initial page load, if the
                // user scrolls through the page very fast. Once the URL is visible, prefetching
                // no longer takes place.
                this.resolvedCache[url] = true; // Return the JSON-LD response back up!

                return _context4.abrupt("return", response.body);

              case 25:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function fetchData(_x3) {
        return _fetchData.apply(this, arguments);
      }

      return fetchData;
    }()
  }, {
    key: "postData",
    value: function () {
      var _postData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(data) {
        var request;
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                request = {
                  key: data.key,
                  action: data.action,
                  context: data.context
                };
                _context5.next = 3;
                return api.request('post', "".concat(this.resolverUrl, "/invoke"), request);

              case 3:
                return _context5.abrupt("return", _context5.sent);

              case 4:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function postData(_x4) {
        return _postData.apply(this, arguments);
      }

      return postData;
    }()
  }]);

  return CardClient;
}();

export { CardClient as default };