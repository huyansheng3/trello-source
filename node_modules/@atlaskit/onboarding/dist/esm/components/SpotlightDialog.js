import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _defineProperty from "@babel/runtime/helpers/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

import React, { Component } from 'react';
import FocusLock from 'react-focus-lock';
import { createAndFireEvent, withAnalyticsContext, withAnalyticsEvents } from '@atlaskit/analytics-next';
import { Popper } from '@atlaskit/popper';
import { Image } from '../styled/Dialog';
import SpotlightCard from './SpotlightCard';
import ValueChanged from './ValueChanged';
var packageName = "@atlaskit/onboarding";
var packageVersion = "10.2.2";

var SpotlightDialog = /*#__PURE__*/function (_Component) {
  _inherits(SpotlightDialog, _Component);

  var _super = _createSuper(SpotlightDialog);

  function SpotlightDialog() {
    var _this;

    _classCallCheck(this, SpotlightDialog);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "state", {
      focusLockDisabled: true
    });

    return _this;
  }

  _createClass(SpotlightDialog, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      this.focusLockTimeoutId = window.setTimeout(function () {
        // we delay the enabling of the focus lock to avoid the scroll position
        // jumping around in some situations
        _this2.setState({
          focusLockDisabled: false
        });
      }, 200);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      window.clearTimeout(this.focusLockTimeoutId);
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          actions = _this$props.actions,
          actionsBeforeElement = _this$props.actionsBeforeElement,
          animationStyles = _this$props.animationStyles,
          children = _this$props.children,
          dialogPlacement = _this$props.dialogPlacement,
          dialogWidth = _this$props.dialogWidth,
          footer = _this$props.footer,
          header = _this$props.header,
          heading = _this$props.heading,
          headingAfterElement = _this$props.headingAfterElement,
          image = _this$props.image,
          targetNode = _this$props.targetNode,
          testId = _this$props.testId;
      var focusLockDisabled = this.state.focusLockDisabled;
      var translatedPlacement = dialogPlacement ? {
        'top left': 'top-start',
        'top center': 'top',
        'top right': 'top-end',
        'right top': 'right-start',
        'right middle': 'right',
        'right bottom': 'right-end',
        'bottom left': 'bottom-start',
        'bottom center': 'bottom',
        'bottom right': 'bottom-end',
        'left top': 'left-start',
        'left middle': 'left',
        'left bottom': 'left-end'
      }[dialogPlacement] : undefined; // If there's no room on either side of the popper, it will extend off-screen.
      //  This looks buggy when scroll-lock and focus is placed on the dialog, so we
      //  customise popper so it overflows the spotlight instead with altAxis=true.

      var modifiers = [{
        name: 'preventOverflow',
        options: {
          padding: 5,
          rootBoundary: 'document',
          altAxis: true,
          tether: false
        }
      }];
      return /*#__PURE__*/React.createElement(Popper, {
        modifiers: modifiers,
        referenceElement: targetNode,
        placement: translatedPlacement
      }, function (_ref) {
        var ref = _ref.ref,
            style = _ref.style,
            update = _ref.update;
        return /*#__PURE__*/React.createElement(ValueChanged, {
          value: dialogWidth,
          onChange: update
        }, /*#__PURE__*/React.createElement(FocusLock, {
          disabled: focusLockDisabled,
          returnFocus: false,
          autoFocus: true
        }, /*#__PURE__*/React.createElement(SpotlightCard, {
          ref: ref,
          testId: testId,
          theme: function theme(parent) {
            var _parent = parent({}),
                container = _parent.container,
                others = _objectWithoutProperties(_parent, ["container"]);

            return _objectSpread(_objectSpread({}, others), {}, {
              container: _objectSpread(_objectSpread(_objectSpread({}, container), style), animationStyles)
            });
          },
          width: dialogWidth,
          actions: actions,
          actionsBeforeElement: actionsBeforeElement,
          image: image && /*#__PURE__*/React.createElement(Image, {
            alt: heading,
            src: image
          }),
          components: {
            Header: header,
            Footer: footer
          },
          heading: heading,
          headingAfterElement: headingAfterElement
        }, children)));
      });
    }
  }]);

  return SpotlightDialog;
}(Component);

var createAndFireEventOnAtlaskit = createAndFireEvent('atlaskit');
export default withAnalyticsContext({
  componentName: 'spotlight',
  packageName: packageName,
  packageVersion: packageVersion
})(withAnalyticsEvents({
  targetOnClick: createAndFireEventOnAtlaskit({
    action: 'clicked',
    actionSubject: 'spotlight',
    attributes: {
      componentName: 'spotlight',
      packageName: packageName,
      packageVersion: packageVersion
    }
  })
})(SpotlightDialog));