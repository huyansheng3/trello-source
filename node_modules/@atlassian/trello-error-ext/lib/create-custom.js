/* eslint-disable
  strict,
  func-names,
  no-caller,
  no-restricted-properties
*/

const hasProp = Object.prototype.hasOwnProperty;

function subclass(child, parent) {
  for (const key in parent) {
    if (hasProp.call(parent, key)) {
      child[key] = parent[key];
    }
  }

  function Ctor() {
    this.constructor = child;
  }

  Ctor.prototype = parent.prototype;
  child.prototype = new Ctor();
  child.__super__ = parent.prototype;
}

function extendFactory(predicate) {
  return function(...rest) {
    const extenders = Array.prototype.slice.call(rest, 1);
    const target = rest[0];
    for (let i = 0; i < extenders.length; i++) {
      const extender = extenders[i];
      for (const key in extender) {
        if (!hasProp.call(extender, key)) {
          continue;
        }
        if (predicate(target, key, extender)) {
          target[key] = extender[key];
        }
      }
    }

    return target;
  };
}

const extend = extendFactory(() => true);

const defaults = extendFactory(
  (target, key) => typeof target[key] === 'undefined'
);

// This takes a string as a name and some optional custom attributes and create
// and return an error class that can be used as a method similar to Error while
// still providing backtraces.
//
// Downside: the constructor.name will always be TrelloError. There is no way
// around this without duplicating this same constructor code everywhere. What
// this means is that if you are debugging in node inspector, it will be labeled
// "TrelloError" even though it has its own, specific name property.
module.exports = function(name, defaultAttributes, baseErrorClass) {
  if (baseErrorClass == null) {
    baseErrorClass = Error;
  }
  function TrelloError(message, attributes) {
    if (!(this instanceof TrelloError)) {
      const error = new TrelloError(message, attributes);
      // Make sure the stack trace does not include the "new TrelloError" call
      if (Error.captureStackTrace != null) {
        Error.captureStackTrace(error, arguments.callee);
      }
      return error;
    }

    Error.call(this);
    if (Error.captureStackTrace != null) {
      Error.captureStackTrace(this, arguments.callee);
    }

    // Explicitly set this because the default is ''. If we passed nothing, it
    // will be undefined and the defaults call has a chance to overwrite it.
    this.message = message;

    // Make sure we set this after the error call above
    defaults(this, attributes, defaultAttributes);

    // Now that the message was set through either the constructor or the error
    // defaults, we can encapsulate it behind a getter
    let _message = this.message || message;
    delete this.message;

    Object.defineProperty(this, 'message', {
      get() {
        return this.getMessage(_message);
      },
      set(value) {
        _message = value;
      },
    });
  }

  subclass(TrelloError, baseErrorClass);

  TrelloError.prototype.name = name;

  // You can override this method so that any reference to message (i.e., the
  // property, a toString() call, or a formatted stack) will be computed on the
  // fly with extra information in the attributes.
  TrelloError.prototype.getMessage = function(message) {
    return message;
  };

  TrelloError.prototype.toObject = function() {
    const result = {};

    for (const key in this) {
      if (!hasProp.call(this, key)) {
        continue;
      }
      result[key] = this[key];
    }

    return result;
  };

  TrelloError.prototype.toJSON = function() {
    return extend(
      {
        message: this.message,
      },
      this.toObject()
    );
  };

  return TrelloError;
};
