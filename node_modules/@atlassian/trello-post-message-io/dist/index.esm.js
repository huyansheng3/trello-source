function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

var customError = require('custom-error');

var Deque = require('double-ended-queue');

var xtend = require('xtend');

var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
var ERR_DISABLED = 'plugin disabled';
var ERR_INVALID_CONTEXT = 'invalid context';
var ERR_NOT_HANDLED = 'not handled';
var ERR_UNSUPPORTED_COMMAND = 'unsupported command';

var IO =
/*#__PURE__*/
function () {
  function IO(options) {
    _classCallCheck(this, IO);

    this.local = options.local;
    this.remote = options.remote;
    this.targetOrigin = options.targetOrigin;
    this.secret = options.secret;
    this.handlers = options.handlers;
    this.hostHandlers = options.hostHandlers;
    this.Promise = options.Promise || window.Promise;
    this.bufferSize = options.bufferSize || 256;
    this._seed = IO.randomId(16);
    this._ctr = 0;
    this._pendingRequests = {};
    this._messageQueues = new Map();

    try {
      this._messageQueues.set(this.remote, new Deque(this.bufferSize));
    } catch (err) {
      this._targetsFallback = {
        remote: this.remote
      };
    }

    this.listen();
  }

  _createClass(IO, [{
    key: "_handleMessage",
    value: function _handleMessage(body, source) {
      var _this = this;

      var data = body.data;

      switch (body.type) {
        case 'request':
          this._handleRequest(data.id, data.command, data.args, source);

          break;

        case 'response':
          this._handleResponse(data.to, data.success, data.response);

          break;

        case 'bulk':
          data.forEach(function (d) {
            return _this._handleMessage(d, source);
          });
          break;

        default:
          break;
      }
    }
  }, {
    key: "listen",
    value: function listen() {
      var _this2 = this;

      this.stop();

      this.listener = function (e) {
        var source = e.source; // we only care about messages from our known remote
        // or any source that knows the secret

        if (source === _this2.remote || e.data.secret === _this2.secret) {
          _this2._handleMessage(e.data, source);
        }
      };

      this.local.addEventListener('message', this.listener);
    }
  }, {
    key: "stop",
    value: function stop() {
      this.local.removeEventListener('message', this.listener);
    }
  }, {
    key: "_handleRequest",
    value: function _handleRequest(id, command, args, source) {
      var _this3 = this;

      var host = xtend(this.hostHandlers, {
        PluginDisabled: IO.PluginDisabled,
        InvalidContext: IO.InvalidContext,
        NotHandled: IO.NotHandled,
        command: command,
        args: args,
        source: source,
        request: function request() {
          for (var _len = arguments.length, reqArgs = new Array(_len), _key = 0; _key < _len; _key++) {
            reqArgs[_key] = arguments[_key];
          }

          return _this3.request.apply(_this3, _toConsumableArray(reqArgs.concat([source])));
        },
        secret: this.secret
      });
      this.Promise.try(function () {
        if (!Object.prototype.hasOwnProperty.call(_this3.handlers, command)) {
          throw new IO.UnsupportedCommand("unsupported command: ".concat(command));
        }

        return _this3.handlers[command].apply(_this3, [host].concat(args));
      }).then(function (response) {
        _this3.respond(id, true, response, source);
      }).catch(function (error) {
        _this3.respond(id, false, {
          code: error.code,
          message: error.message
        }, source);
      });
    }
  }, {
    key: "_handleResponse",
    value: function _handleResponse(to, success, response) {
      if (!Object.prototype.hasOwnProperty.call(this._pendingRequests, to)) {
        return;
      }

      if (success) {
        this._pendingRequests[to].resolve(response);

        delete this._pendingRequests[to];
      } else {
        var error = null;

        switch (response.code) {
          case ERR_DISABLED:
            error = new IO.PluginDisabled(response.message);
            break;

          case ERR_INVALID_CONTEXT:
            error = new IO.InvalidContext(response.message);
            break;

          case ERR_NOT_HANDLED:
            error = new IO.NotHandled(response.message);
            break;

          case ERR_UNSUPPORTED_COMMAND:
            error = new IO.UnsupportedCommand(response.message);
            break;

          default:
            error = new Error(response.message);
        }

        this._pendingRequests[to].reject(error);

        delete this._pendingRequests[to];
      }
    }
  }, {
    key: "raw",
    value: function raw(type, data, target) {
      var _this4 = this;

      if (type === 'bulk') {
        var message = {
          data: data,
          secret: this.secret,
          type: type
        };

        if (target) {
          target.postMessage(message, '*');
        } else {
          this.remote.postMessage(message, this.targetOrigin);
        }
      } else {
        var qKey = target || this.remote;

        if (this._targetsFallback) {
          // the Trello webclient polyfills Map for IE11 meaning we can't
          // set keys of the Map to cross-domain windows :(
          if (target === this.remote) {
            qKey = 'remote';
          } else {
            qKey = undefined;
            var targetKeys = Object.keys(this._targetsFallback); // oldschool loop so we can easily short-circuit
            // eslint-disable-next-line no-plusplus

            for (var i = 0; i < targetKeys.length; i++) {
              var k = targetKeys[i];

              if (this._targetsFallback[k] === target) {
                qKey = k;
                break;
              }
            }

            if (!qKey) {
              qKey = IO.randomId(8);
              this._targetsFallback[qKey] = target;
            }
          }
        }

        if (!this._messageQueues.has(qKey)) {
          this._messageQueues.set(qKey, new Deque(this.bufferSize));
        }

        var queue = this._messageQueues.get(qKey);

        if (queue.isEmpty()) {
          setTimeout(function () {
            return _this4.emptyQueue(qKey);
          }, 0);
        }

        queue.push({
          type: type,
          data: data
        });
      }
    }
  }, {
    key: "emptyQueue",
    value: function emptyQueue(key) {
      var queue = this._messageQueues.get(key);

      if (!queue.isEmpty()) {
        var messages = queue.toArray();
        queue.clear();
        var target = typeof key === 'string' ? this._targetsFallback[key] : key;

        if (key !== this.remote && key !== 'remote') {
          // don't hold on to generally short lived targets
          this._messageQueues.delete(key);

          if (this._targetsFallback) {
            delete this._targetsFallback[key];
          }
        }

        this.raw('bulk', messages, target);
      }
    }
  }, {
    key: "request",
    value: function request(command) {
      var _this5 = this;

      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      this._ctr += 1;
      var id = this._seed + this._ctr;
      var lastArg = args[args.length - 1];
      var target;

      if (lastArg && typeof lastArg.postMessage === 'function') {
        target = args.pop();
      }

      this.raw('request', {
        args: args,
        command: command,
        id: id
      }, target);
      return new this.Promise(function (resolve, reject) {
        _this5._pendingRequests[id] = {
          args: args,
          command: command,
          id: id,
          reject: reject,
          resolve: resolve
        };
      });
    }
  }, {
    key: "respond",
    value: function respond(idRequest, success, response, target) {
      this.raw('response', {
        response: response,
        success: success,
        to: idRequest
      }, target);
    }
  }], [{
    key: "randomId",
    value: function randomId(length) {
      var idLength = length || 16;
      var rands = [];

      if (window.crypto && window.crypto.getRandomValues) {
        rands = window.crypto.getRandomValues(new Uint32Array(idLength));
      } else if (_typeof(window.msCrypto) === 'object' && typeof window.msCrypto.getRandomValues === 'function') {
        // IE11 fallback
        rands = window.msCrypto.getRandomValues(new Uint32Array(idLength));
      } else {
        // IE10 fallback
        while (rands.length < idLength) {
          rands.push(Math.floor(Math.random() * alphabet.length));
        }
      }

      var id = [];

      for (var i = 0; i < idLength; i += 1) {
        id.push(alphabet[rands[i] % alphabet.length]);
      }

      return id.join('');
    }
  }]);

  return IO;
}();

IO.PluginDisabled = customError('PostMessageIO:PluginDisabled');
IO.PluginDisabled.prototype.code = ERR_DISABLED;
IO.InvalidContext = customError('PostMessageIO:InvalidContext');
IO.InvalidContext.prototype.code = ERR_INVALID_CONTEXT;
IO.NotHandled = customError('PostMessageIO:NotHandled');
IO.NotHandled.prototype.code = ERR_NOT_HANDLED;
IO.UnsupportedCommand = customError('PostMessageIO:UnsupportedCommand');
IO.UnsupportedCommand.prototype.code = ERR_UNSUPPORTED_COMMAND;
module.exports = IO;
