import _regeneratorRuntime from "@babel/runtime/regenerator";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import { useEffect, useState } from 'react';
import { postHeartbeat } from '../../services/heartbeat';
export var useHearbeatService = function useHearbeatService(endpoint, onAuthenticationFailed) {
  var _useState = useState(undefined),
      _useState2 = _slicedToArray(_useState, 2),
      requestTimestamp = _useState2[0],
      setRequestTimestamp = _useState2[1];

  var _useState3 = useState(undefined),
      _useState4 = _slicedToArray(_useState3, 2),
      sessionExpiryTimestamp = _useState4[0],
      setSessionExpiryTimestamp = _useState4[1];

  var _useState5 = useState(false),
      _useState6 = _slicedToArray(_useState5, 2),
      callHeartbeatService = _useState6[0],
      setCallHeartbeatService = _useState6[1];

  useEffect(function () {
    if (callHeartbeatService && endpoint) {
      var callAsync = /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
          var response;
          return _regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return postHeartbeat(endpoint, onAuthenticationFailed);

                case 2:
                  response = _context.sent;
                  setCallHeartbeatService(false);

                  if (response && response.nextCallTimestamp) {
                    setRequestTimestamp(new Date(response.nextCallTimestamp));
                  }

                  if (response && response.sessionExpiryTime) {
                    setSessionExpiryTimestamp(new Date(response.sessionExpiryTime));
                  }

                case 6:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        return function callAsync() {
          return _ref.apply(this, arguments);
        };
      }();

      callAsync();
    }
  }, [callHeartbeatService, endpoint, onAuthenticationFailed]);
  return {
    requestTimestamp: requestTimestamp,
    sessionExpiryTimestamp: sessionExpiryTimestamp,
    callHeartbeatService: callHeartbeatService,
    setCallHeartbeatService: setCallHeartbeatService
  };
};