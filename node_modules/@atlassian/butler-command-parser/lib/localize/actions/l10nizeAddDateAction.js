"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.l10nizeAddDateAction = void 0;
const LocalizationKeysError_1 = require("../LocalizationKeysError");
const isNonNegative = (num) => Number.isFinite(num) && (num !== null && num !== void 0 ? num : 0) >= 0;
const parseDateField = (date) => {
    if (date.NOW) {
        return 'now';
    }
    if (date.TODAY) {
        return 'today';
    }
    if (date.TOMORROW) {
        return 'tomorrow';
    }
    if (date.YESTERDAY) {
        return 'yesterday';
    }
    if (date.NEXT_WEEK) {
        return date.NEXT_WEEK.DAY !== undefined
            ? { key: 'next week on day', '*WEEKDAY': date.NEXT_WEEK.DAY }
            : 'next week';
    }
    if (date.NEXT_MONTH) {
        return {
            key: date.NEXT_MONTH.MONTH_DAY_NUMBER ? 'next month on the day' : 'next month',
            '*ORDINAL': date.NEXT_MONTH.MONTH_DAY_NUMBER,
        };
    }
    if (date.THE_NEXT_WORKING_DAY) {
        return 'the next working day';
    }
    if (isNonNegative(date.IN_MINUTES)) {
        return { key: 'x time frame later', $X: date.IN_MINUTES, time_frame: 'minutes' };
    }
    if (isNonNegative(date.IN_HOURS)) {
        return { key: 'x time frame later', $X: date.IN_HOURS, time_frame: 'hours' };
    }
    if (date.IN_X_FROM_TODAY) {
        if (isNonNegative(date.IN_X_FROM_TODAY.X_WORKING_DAYS)) {
            return {
                key: 'x time frame later',
                $X: date.IN_X_FROM_TODAY.X_WORKING_DAYS,
                time_frame: 'working days',
            };
        }
        if (isNonNegative(date.IN_X_FROM_TODAY.X_DAYS)) {
            return {
                key: 'x time frame later',
                $X: date.IN_X_FROM_TODAY.X_DAYS,
                time_frame: 'days',
            };
        }
        if (isNonNegative(date.IN_X_FROM_TODAY.X_WEEKS)) {
            return {
                key: 'x time frame later',
                $X: date.IN_X_FROM_TODAY.X_WEEKS,
                time_frame: 'weeks',
            };
        }
        if (isNonNegative(date.IN_X_FROM_TODAY.X_MONTHS)) {
            return {
                key: 'x time frame later',
                $X: date.IN_X_FROM_TODAY.X_MONTHS,
                time_frame: 'months',
            };
        }
    }
    if (date.BEFORE_DAY) {
        return {
            key: date.BEFORE_DAY.END_OF_DAY !== undefined ? 'before the end of day' : 'before day',
            '*WEEKDAY': date.BEFORE_DAY.DAY,
        };
    }
    if (date.NEXT_DAY !== undefined) {
        return { key: 'next day', '*WEEKDAY': date.NEXT_DAY.DAY };
    }
    if (date.MONTH_DAY) {
        let day;
        if (date.MONTH_DAY.LAST_MONTH_DAY) {
            day = Object.prototype.hasOwnProperty.call(date.MONTH_DAY.LAST_MONTH_DAY, 'WORKING')
                ? 'last working day'
                : 'last day';
        }
        else {
            day = { key: 'ordinal', '*ORDINAL': date.MONTH_DAY.MONTH_DAY_NUMBER };
        }
        return {
            key: 'the day of month',
            day,
            month: date.MONTH_DAY.WHICH_MONTH_NEXT ? 'next month' : 'the month',
        };
    }
    if (date.NTH_WEEK_DAY) {
        return {
            key: 'the day of month',
            day: date.NTH_WEEK_DAY.LAST_MONTH_WEEK
                ? { key: 'last weekday', '*WEEKDAY': date.NTH_WEEK_DAY.DAY }
                : {
                    key: 'nth day',
                    '*ORDINAL': date.NTH_WEEK_DAY.MONTH_WEEK_NUMBER,
                    '*WEEKDAY': date.NTH_WEEK_DAY.DAY,
                },
            month: 'the month',
        };
    }
    if (date.WRITTEN_DATE) {
        if (date.WRITTEN_DATE.END_OF_MONTH) {
            return {
                key: 'the day of month',
                day: 'last day',
                month: { key: 'month', '*MONTH': date.WRITTEN_DATE.MONTH },
            };
        }
        return {
            key: 'written date',
            '*DATE': {
                key: 'date',
                month: date.WRITTEN_DATE.MONTH,
                day: date.WRITTEN_DATE.MONTH_DAY_NUMBER,
                year: date.WRITTEN_DATE.YEAR,
            },
        };
    }
    // undefined can be valid if `TIME` exists, e.g. `set due date at 12pm`.
    return undefined;
};
function l10nizeAddDateAction(action) {
    const data = action.type === 'ADD_START_DATE_ACTION'
        ? action.ADD_START_DATE_ACTION.START_DATE
        : action.ADD_DUE_DATE_ACTION.DUE_DATE;
    const dateField = parseDateField(data);
    if (!dateField && !data.TIME) {
        throw new LocalizationKeysError_1.LocalizationKeysError(action.type, ['NUMERIC_DATE', 'DATE_IN_CUSTOM_FIELD'].find((x) => Object.prototype.hasOwnProperty.call(data, x)));
    }
    return {
        key: 'add_date_action',
        date_type: { key: action.type === 'ADD_START_DATE_ACTION' ? 'start date' : 'due date' },
        date: dateField,
        // If this logic gets reused in a few places, it might make better sense
        // in a common file.
        time: data.TIME
            ? {
                key: 'at time',
                // `time` key is unused, but needed to maintain interface.
                '*TIME': Object.assign({ key: 'time' }, data.TIME),
            }
            : undefined,
    };
}
exports.l10nizeAddDateAction = l10nizeAddDateAction;
