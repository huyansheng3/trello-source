"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.localize = void 0;
const specialCaseTranslations_json_1 = __importDefault(require("./specialCaseTranslations.json"));
const translations_json_1 = __importDefault(require("./translations.json"));
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const SPECIAL_CASE_LOCALIZATIONS = {
    '*COLOR': (color) => color,
    '*DATE': ({ month, day = 1, year }) => {
        let date = `${specialCaseTranslations_json_1.default.months[month]} ${day}`;
        if (year) {
            date += `, ${year}`;
        }
        return date;
    },
    '*MONTH': (month) => specialCaseTranslations_json_1.default.months[month],
    '*ORDINAL': (num) => {
        switch (num) {
            case 1:
                return '1st';
            case 2:
                return '2nd';
            case 3:
                return '3rd';
            case undefined:
                return undefined;
            default:
                return `${num}th`;
        }
    },
    '*STICKER': (index) => specialCaseTranslations_json_1.default.stickers[index],
    /**
     * Format a time localization key with hours, minutes, and period (AM/PM).
     * Since this is unformatted from user input, we can basically just show what
     * they sent us.
     */
    '*TIME': ({ HOUR, MINUTES, AM, PM }) => {
        let time = String(HOUR);
        if (typeof MINUTES !== 'undefined') {
            let minutes = String(MINUTES);
            if (minutes.length < 2) {
                minutes = `0${minutes}`;
            }
            time += `:${minutes}`;
        }
        // AM and PM are stored as strings `am` or `pm`.
        if (AM || PM) {
            time += ` ${(AM || PM || '').toUpperCase()}`;
        }
        return time;
    },
    '*WEEKDAY': (day) => specialCaseTranslations_json_1.default.weekdays[day],
};
// We need to allowlist actions if they have a variable value that is not nested
// in double quotes
// For example, 'set custom field "test" to {var}' is different from 'set custom field "test" to "{var}"'
// (where the latter is considered to be a text value instead of a variable value)
const hasVariableValue = new Set([
    'verb_custom_field_to_value_action',
    'due in between days',
    'due in comparison days',
]);
function sanitizeCommand(key, command) {
    // Remove fields that don't actually have substitutions
    // Create command without quotes so user input with {} aren't affected
    const commandWithoutQuotes = command.replace(/("[^"]+")/g, '');
    // Find matches for fields that don't have substitutions
    const validMatches = commandWithoutQuotes.match(/{[^{}]+}/g);
    // Some commands have variables and we don't want to remove those
    if (validMatches && !hasVariableValue.has(key)) {
        validMatches.forEach((match) => {
            // Remove the extra space before it too
            command = command.replace(` ${match}`, '');
        });
    }
    return command;
}
function format(key, substitutions) {
    let command = translations_json_1.default[key];
    if (!command) {
        throw new Error(`${key} not found in translations`);
    }
    if (substitutions) {
        for (const [substitutionKey, substitutionValue] of Object.entries(substitutions)) {
            command = command.replace(`{${substitutionKey}}`, substitutionValue);
        }
    }
    return command;
}
function substitute(prop, value) {
    var _a;
    if (Array.isArray(value)) {
        return value.map((v) => substitute(prop, v)).join(' and ');
    }
    // Special cases where standing up individual translation keys is inefficient;
    // e.g. label names (since clients have their own translations for these) and
    // ordinals (like 2 -> 2nd).
    if (prop.startsWith('*')) {
        if (typeof value !== 'undefined') {
            return (_a = SPECIAL_CASE_LOCALIZATIONS[prop]) === null || _a === void 0 ? void 0 : _a.call(SPECIAL_CASE_LOCALIZATIONS, value);
        }
    }
    switch (typeof value) {
        case 'number': {
            return String(value);
        }
        case 'string': {
            // Input strings are prepended with a `$`, like `$LIST` name.
            if (prop.startsWith('$')) {
                return value;
                // Member usernames are prepended with a `@`.
            }
            else if (prop.startsWith('@')) {
                return `@${value}`;
            }
            else {
                const formattedValue = format(value);
                if (!formattedValue) {
                    throw new Error(`Could not localize ${value}`);
                }
                return value;
            }
        }
        case 'object': {
            // `value` is a nested LocalizationKey; recurse.
            return _localize(value);
        }
        default:
            return;
    }
}
function _localize(_a) {
    var { key } = _a, props = __rest(_a, ["key"]);
    const substitutions = Object.entries(props).reduce((acc, [prop, value]) => {
        const substitution = substitute(prop, value);
        if (substitution) {
            acc[prop] = substitution;
        }
        return acc;
    }, {});
    return format(key, substitutions);
}
const localize = (localizationKey) => sanitizeCommand(localizationKey.key, _localize(localizationKey));
exports.localize = localize;
