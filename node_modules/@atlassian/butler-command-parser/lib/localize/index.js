"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.localizeCommandToButlerEnglish = exports.getLocalizationKeysForCommand = void 0;
const localize_1 = require("./localize");
const actions_1 = require("./actions");
const triggers_1 = require("./triggers");
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function sanitizeItem(item) {
    if (typeof item === 'string') {
        return item.replace(/"/g, `\\"`);
    }
    if (Array.isArray(item)) {
        return item.map(sanitizeItem);
    }
    if (!!item && typeof item === 'object') {
        return Object.keys(item).reduce((acc, key) => (Object.assign(Object.assign({}, acc), { [key]: sanitizeItem(item[key]) })), {});
    }
    return item;
}
const sanitizeCommand = ({ TRIGGER, ACTION }) => ({
    TRIGGER: sanitizeItem(TRIGGER),
    ACTION: sanitizeItem(ACTION),
});
function getLocalizationKeysForCommand(command) {
    const { ACTION, TRIGGER } = sanitizeCommand(command);
    const result = {
        actions: ACTION.map(actions_1.getLocalizationKeysForAction),
    };
    if (TRIGGER) {
        result.trigger = triggers_1.getLocalizationKeysForTrigger(TRIGGER);
    }
    return result;
}
exports.getLocalizationKeysForCommand = getLocalizationKeysForCommand;
function localizeActions(actions) {
    // logic matches butler-client phrase joining
    const phrases = actions.map((action) => localize_1.localize(action));
    return phrases.length > 1
        ? phrases.slice(0, -1).join(',\n') +
            (phrases[phrases.length - 2].match(/^for each /) ? ',\n' : ',\nand ') +
            phrases.slice(-1)[0]
        : phrases[0];
}
function localizeCommandToButlerEnglish(command) {
    const { actions, trigger } = getLocalizationKeysForCommand(command);
    const localizedActions = localizeActions(actions);
    if (trigger) {
        return `${localize_1.localize(trigger)},\n${localizedActions}`;
    }
    return localizedActions;
}
exports.localizeCommandToButlerEnglish = localizeCommandToButlerEnglish;
