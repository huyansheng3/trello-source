"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.flatten = void 0;
const assert_1 = __importDefault(require("assert"));
const globals_1 = require("../globals");
const internal_1 = require("./internal");
const kMakeSiblingSymbol = '__â¤£';
function flatten(parse_tree, left_symbol) {
    switch (typeof parse_tree) {
        case 'string':
        case 'number':
            return parse_tree;
        case 'object': {
            if (Array.isArray(parse_tree)) {
                if (parse_tree.indexOf(kMakeSiblingSymbol) !== -1) {
                    return splitArray(parse_tree, kMakeSiblingSymbol).map(function (subarray) {
                        return flatten(subarray, left_symbol);
                    });
                }
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                const values = {};
                let count = 0;
                parse_tree.forEach(function (branch) {
                    const flat_branch = flatten(branch, left_symbol);
                    if (globals_1.DEBUG) {
                        globals_1.Logger.info('flatten array item', { left_symbol, branch, flat_branch });
                    }
                    if (typeof flat_branch !== 'object') {
                        return;
                    }
                    for (const key in flat_branch) {
                        values[key] = (values[key] || []).concat(flat_branch[key]);
                        ++count;
                    }
                });
                if (!count) {
                    return true;
                }
                for (const key in values) {
                    if (key !== 'ACTION' && key !== 'CONDITION' && values[key].length === 1) {
                        values[key] = values[key][0];
                    }
                    if (key === 'ACTION' || key === 'CONDITION') {
                        // assigns type to each action or condition
                        values[key].forEach((cmd) => {
                            cmd.type = Object.keys(cmd)[0];
                        });
                    }
                    else if (key === 'TRIGGER') {
                        // assigns type to trigger like 'WHEN'
                        const type = Object.keys(values[key])[0];
                        values[key].type = type;
                        // assigns type to actual trigger like 'MEMBER_ADDED'
                        const trigger = values[key][type];
                        // some triggers like ON_DUE_DATE are booleans and cannot have a type
                        if (typeof trigger === 'object') {
                            trigger.type = Object.keys(trigger)[0];
                        }
                    }
                }
                return values;
            }
            const keys = Object.keys(parse_tree);
            assert_1.default(keys.length === 1 &&
                (internal_1.isSymbol(keys[0]) ||
                    internal_1.isStringVariable(keys[0]) ||
                    internal_1.isVariableName(keys[0]) ||
                    internal_1.isAtMention(keys[0])), `Expecting one symbol and only one symbol as key for object: ${JSON.stringify(parse_tree)}`);
            const key = keys[0];
            let value = flatten(parse_tree[key], key);
            if (globals_1.DEBUG) {
                globals_1.Logger.info('flatten object value', {
                    left_symbol,
                    parse_tree_key: parse_tree[key],
                    value,
                });
            }
            if (key === left_symbol || internal_1.isHiddenSymbol(key)) {
                return value;
            }
            const tuple = {};
            if (typeof value === 'string') {
                if (internal_1.isStringValue(value)) {
                    value = value.slice(1, -1);
                }
                // Remove quotes.
                else if (internal_1.isAtMentionValue(value)) {
                    value = value.slice(1);
                } // Remove @.
            }
            tuple[key] = value;
            return tuple;
        }
        default:
            assert_1.default(false, `Unexpected branch type: ${JSON.stringify(parse_tree)}`);
            return true;
    }
}
exports.flatten = flatten;
function splitArray(array, delim) {
    const out = [];
    for (;;) {
        const i = array.indexOf(delim);
        if (i === -1) {
            out.push(array);
            return out;
        }
        out.push(array.slice(0, i));
        array = array.slice(i + 1);
    }
}
