"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.correctParseResult = void 0;
const globals_1 = require("../globals");
const internal_1 = require("./internal");
// Corrects a parse result with errors.
function correctParseResult(parse_result, max_errors, max_additions) {
    if (max_additions === undefined) {
        max_additions = 1;
    }
    if (max_errors === undefined) {
        max_errors = 1;
    }
    parse_result.corrections = {
        corrected_errors: 0,
        tokens: parse_result.hint ? parse_result.hint.tokens : [],
        replaced_tokens: [],
        added_tokens: [],
    };
    return corrector(parse_result, max_errors, max_additions);
}
exports.correctParseResult = correctParseResult;
function corrector(result, max_errors, max_additions) {
    if (result.parse || result.halt_message || !max_errors) {
        return result;
    }
    const is_optimal = function (recurse_result) {
        // Minimum is two more corrections on top of the original result,
        // because we've already performed one correction before recursing.
        return (recurse_result.parse &&
            recurse_result.corrections.corrected_errors === result.corrections.corrected_errors + 2);
    };
    const is_better = function (a, b) {
        return a.parse
            ? !b.parse || a.corrections.corrected_errors < b.corrections.corrected_errors
            : !b.parse && a.corrections.corrected_errors < b.corrections.corrected_errors;
    };
    const hint = result.hint;
    if (!hint.expecting.length) {
        const tokens = hint.tokens.slice(0, hint.at_token);
        const new_result = parseCorrection(result, tokens, {});
        return new_result;
    }
    if (hint.at_token === hint.tokens.length) {
        if (!max_additions) {
            return result;
        }
        const append_results = [];
        for (let i = 0; i < hint.expecting.length; ++i) {
            const tokens = hint.tokens.concat(hint.expecting[i]);
            const new_result = parseCorrection(result, tokens, { added_tokens: hint.at_token });
            if (new_result.parse) {
                return new_result;
            }
            append_results.push(new_result);
        }
        let best = null;
        for (let i = 0; i < append_results.length; ++i) {
            const append_result = append_results[i];
            const new_result = corrector(append_result, max_errors - 1, max_additions - 1);
            if (is_optimal(new_result)) {
                return new_result;
            }
            if (!best || is_better(new_result, best)) {
                best = new_result;
            }
        }
        return best;
    }
    const replacements = sortBySimilarity(hint.expecting.slice(), hint.tokens[hint.at_token]);
    const replace_results = [];
    for (let i = 0; i < replacements.length; ++i) {
        const tokens = hint.tokens.slice();
        tokens[hint.at_token] = replacements[i];
        const new_result = parseCorrection(result, tokens, { replaced_tokens: hint.at_token });
        if (new_result.parse) {
            return new_result;
        }
        replace_results.push(new_result);
    }
    const add_results = [];
    if (max_additions) {
        for (let i = 0; i < hint.expecting.length; ++i) {
            const tokens = hint.tokens.slice();
            tokens.splice(hint.at_token, 0, hint.expecting[i]);
            const new_result = parseCorrection(result, tokens, { added_tokens: hint.at_token });
            if (new_result.parse) {
                return new_result;
            }
            add_results.push(new_result);
        }
    }
    let best = null;
    for (let i = 0; i < replace_results.length; ++i) {
        const replace_result = replace_results[i];
        const new_result = corrector(replace_result, max_errors - 1, max_additions);
        if (is_optimal(new_result)) {
            return new_result;
        }
        if (!best || is_better(new_result, best)) {
            best = new_result;
        }
    }
    for (let i = 0; i < add_results.length; ++i) {
        const add_result = add_results[i];
        const new_result = corrector(add_result, max_errors - 1, max_additions - 1);
        if (is_optimal(new_result)) {
            return new_result;
        }
        if (!best || is_better(new_result, best)) {
            best = new_result;
        }
    }
    return best;
}
function parseCorrection(previous_result, tokens, correction) {
    if (globals_1.DEBUG) {
        globals_1.Logger.info('CORRECTION', {
            corrected_errors: previous_result.corrections.corrected_errors,
            tokens,
        });
    }
    const corrections = {
        corrected_errors: previous_result.corrections.corrected_errors + 1,
        tokens: tokens.slice(),
        replaced_tokens: previous_result.corrections.replaced_tokens,
        added_tokens: previous_result.corrections.added_tokens,
    };
    Object.keys(correction).forEach(function (key) {
        corrections[key] = corrections[key].concat(correction[key]);
    });
    const result = internal_1.parseTokens(tokens);
    result.corrections = corrections;
    return result;
}
function sortBySimilarity(tokens, target) {
    const sortedTarget = target.split('').sort();
    const similarity = {};
    tokens.forEach(function (token) {
        const sortedToken = token.split('').sort();
        let i = 0;
        let j = 0;
        let matches = 0;
        let nonmatches = 0;
        while (i < sortedToken.length && j < sortedTarget.length) {
            if (sortedToken[i] < sortedTarget[j]) {
                ++nonmatches;
                ++i;
            }
            else if (sortedToken[i] > sortedTarget[j]) {
                ++nonmatches;
                ++j;
            }
            else {
                ++matches;
                ++i;
                ++j;
            }
        }
        while (i < sortedToken.length) {
            ++nonmatches;
            ++i;
        }
        while (j < sortedTarget.length) {
            ++nonmatches;
            ++j;
        }
        similarity[token] = matches / (matches + nonmatches);
    });
    return tokens.slice().sort(function (a, b) {
        return similarity[b] - similarity[a];
    });
}
