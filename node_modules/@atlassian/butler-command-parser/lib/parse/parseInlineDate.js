"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseInlineDate = void 0;
const internal_1 = require("./internal");
function parseInlineDate(command, options = {}) {
    var _a, _b, _c;
    const tokens = internal_1.tokenize(command);
    const after_tokens = internal_1.tokenize((options === null || options === void 0 ? void 0 : options.after) || '');
    for (let i = 0; i < tokens.length; ++i) {
        if (after_tokens.some((match_token, j) => tokens[i + j] !== match_token)) {
            if (options === null || options === void 0 ? void 0 : options.at_start) {
                break;
            }
            continue;
        }
        const result = internal_1.parseTokens(tokens.slice(i + after_tokens.length), (options === null || options === void 0 ? void 0 : options.at_end) ? 'END_DATE_TIME' : 'INLINE_DATE_TIME');
        if (result === null || result === void 0 ? void 0 : result.parse) {
            const token_indices = internal_1.tokenizeIndices(command).slice(i, result.extra_tokens ? -result.extra_tokens.length : undefined);
            result.match = {
                source_text: command,
                matched_text: command.slice((_a = token_indices[0]) === null || _a === void 0 ? void 0 : _a.from, (_b = token_indices.slice(-1)[0]) === null || _b === void 0 ? void 0 : _b.to),
                match_pos: (_c = token_indices[0]) === null || _c === void 0 ? void 0 : _c.from,
            };
            return result;
        }
        if (options === null || options === void 0 ? void 0 : options.at_start) {
            break;
        }
    }
    return {};
}
exports.parseInlineDate = parseInlineDate;
