"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.swappable = exports.enum_value = exports.or_index = exports.or = exports.hidden = exports.optional = exports.make_sibling = exports.decimal = exports.small_numeral = exports.ordinal = exports.timezone = exports.year = exports.numeric_date = exports.time = exports.trap = void 0;
const assert_1 = __importDefault(require("assert"));
const MaybeArray_1 = require("../types/MaybeArray");
const internal_1 = require("./internal");
const kMakeSiblingSymbol = '__â¤£';
function trap(conditions, halt_message) {
    assert_1.default(arguments.length === 2);
    return {
        parse: (tokens, seen, stall_fn) => {
            if (MaybeArray_1.normalizeArray(conditions).every(function (condition) {
                return condition[0] !== '!'
                    ? seen.indexOf(condition) !== -1
                    : seen.indexOf(condition.slice(1)) === -1;
            })) {
                return stall_fn(tokens, null, halt_message);
            }
            return '_';
        },
    };
}
exports.trap = trap;
function time() {
    return {
        parse: (tokens, seen, stall_fn) => {
            const parsedTime = internal_1.parseTime(tokens);
            if (!parsedTime) {
                return stall_fn(tokens, 'a time, e.g. 8:30am');
            }
            return parsedTime;
        },
    };
}
exports.time = time;
function numeric_date() {
    return {
        parse: (tokens, seen, stall_fn) => {
            const date = internal_1.parseNumericDate(tokens);
            if (!date) {
                return stall_fn(tokens, 'a date in numeric format, e.g. 07/29/2016');
            }
            return date;
        },
    };
}
exports.numeric_date = numeric_date;
function year() {
    return {
        parse: (tokens, seen, stall_fn) => {
            const parsedYear = internal_1.parseYear(tokens);
            if (!parsedYear) {
                return stall_fn(tokens, 'a year, e.g. 2016');
            }
            return parsedYear;
        },
    };
}
exports.year = year;
function timezone() {
    return {
        parse: (tokens, seen, stall_fn) => {
            const parsedTime = internal_1.parseTimezone(tokens);
            if (!parsedTime) {
                return stall_fn(tokens, 'a timezone (check out [this Trello card](https://trello.com/c/7Qd0SKIe/41-timezones) for examples)');
            }
            return parsedTime;
        },
    };
}
exports.timezone = timezone;
function ordinal(stall_message, min, max) {
    return {
        parse: (tokens, seen, stall_fn) => {
            const parsedOrdinal = internal_1.parseOrdinal(tokens);
            if (parsedOrdinal === null) {
                return stall_fn(tokens, stall_message || 'an ordinal number, e.g. third');
            }
            if (typeof min === 'number' && parsedOrdinal < min) {
                return stall_fn(tokens, stall_message || 'a larger ordinal number');
            }
            if (typeof max === 'number' && parsedOrdinal > max) {
                return stall_fn(tokens, stall_message || 'a smaller ordinal number');
            }
            return parsedOrdinal;
        },
    };
}
exports.ordinal = ordinal;
// Only small if written with words, in digits it can be as large as parseInt handles.
function small_numeral(stall_message, accept_negatives, min, max) {
    return {
        parse: (tokens, seen, stall_fn) => {
            const number = internal_1.parseSmallNumeral(tokens, accept_negatives);
            if (number === null) {
                return stall_fn(tokens, stall_message || 'a number');
            }
            if (typeof min === 'number' && number < min) {
                return stall_fn(tokens, stall_message || `a number larger than or equal to ${min}`);
            }
            if (typeof max === 'number' && number > max) {
                return stall_fn(tokens, stall_message || `a number smaller than or equal to ${max}`);
            }
            return number;
        },
    };
}
exports.small_numeral = small_numeral;
function decimal(stall_message, accept_negatives, min, max) {
    return {
        parse: (tokens, seen, stall_fn) => {
            const number = internal_1.parseDecimal(tokens, accept_negatives);
            if (number === null) {
                return stall_fn(tokens, stall_message || 'a decimal number');
            }
            if (typeof min === 'number' && number < min) {
                return stall_fn(tokens, stall_message || `a number larger than or equal to ${min}`);
            }
            if (typeof max === 'number' && number > max) {
                return stall_fn(tokens, stall_message || `a number smaller than or equal to ${max}`);
            }
            return number;
        },
    };
}
exports.decimal = decimal;
const make_sibling = () => ({
    parse: () => kMakeSiblingSymbol,
});
exports.make_sibling = make_sibling;
function optional(rule) {
    assert_1.default(arguments.length === 1);
    return {
        parse: (tokens, seen, stall_fn) => {
            const tokens_copy = tokens.slice();
            const seen_copy = seen.slice();
            const parsed = internal_1.parser(tokens_copy, rule, seen_copy, stall_fn);
            if (parsed === null) {
                return '_';
            }
            tokens.splice(0, tokens.length - tokens_copy.length);
            seen.push(...seen_copy.slice(seen.length));
            return parsed;
        },
    };
}
exports.optional = optional;
function hidden(rule) {
    assert_1.default(arguments.length === 1);
    return {
        parse: (tokens, seen, stall_fn) => {
            return internal_1.parser(tokens, rule, seen, function (current_tokens) {
                return stall_fn(current_tokens);
            });
        },
    };
}
exports.hidden = hidden;
function or(...args) {
    const rules = [...args];
    return {
        parse: (tokens, seen, stall_fn) => {
            for (let i = 0; i < rules.length; ++i) {
                const tokens_copy = tokens.slice();
                const seen_copy = seen.slice();
                const parsed = internal_1.parser(tokens_copy, rules[i], seen_copy, stall_fn);
                if (parsed !== null && parsed !== undefined) {
                    tokens.splice(0, tokens.length - tokens_copy.length);
                    seen.push(...seen_copy.slice(seen.length));
                    return parsed;
                }
            }
            return null;
        },
    };
}
exports.or = or;
function or_index(...args) {
    const rules = [...args];
    return {
        parse: (tokens, seen, stall_fn) => {
            for (let i = 0; i < rules.length; ++i) {
                const tokens_copy = tokens.slice();
                const seen_copy = seen.slice();
                const parsed = internal_1.parser(tokens_copy, rules[i], seen_copy, stall_fn);
                if (parsed) {
                    tokens.splice(0, tokens.length - tokens_copy.length);
                    seen.push(...seen_copy.slice(seen.length));
                    return i;
                }
            }
            return null;
        },
    };
}
exports.or_index = or_index;
function enum_value(...args) {
    const rules = [...args];
    return {
        parse: (tokens, seen, stall_fn) => {
            for (const rule of rules) {
                const tokens_copy = tokens.slice();
                const seen_copy = seen.slice();
                const parsed = internal_1.parser(tokens_copy, rule, seen_copy, stall_fn);
                if (parsed) {
                    tokens.splice(0, tokens.length - tokens_copy.length);
                    seen.push(...seen_copy.slice(seen.length));
                    return rule;
                }
            }
            return null;
        },
    };
}
exports.enum_value = enum_value;
function swappable(
/* eslint-disable @typescript-eslint/no-explicit-any */
a, b, delim
/* eslint-enable @typescript-eslint/no-explicit-any */
) {
    return {
        parse: (tokens, seen, stall_fn) => {
            assert_1.default(!(typeof a === 'string' && internal_1.isOptional(a)) &&
                !(typeof a.parse === 'function' && a.parse.name === 'optional'), 'Setting the first argument in a swappable as optional prevents the swap from being accepted.');
            let tokens_copy = tokens.slice();
            let seen_copy = seen.slice();
            let parse_a = internal_1.parser(tokens_copy, a, seen_copy, stall_fn);
            let parse_b = delim ? internal_1.parser(tokens_copy, delim, seen_copy, stall_fn) : [];
            let parse_d = internal_1.parser(tokens_copy, b, seen_copy, stall_fn);
            if (parse_a && parse_d && parse_b) {
                tokens.splice(0, tokens.length - tokens_copy.length);
                seen.push(...seen_copy.slice(seen.length));
                return [].concat(parse_a, parse_d, parse_b);
            }
            tokens_copy = tokens.slice();
            seen_copy = seen.slice();
            parse_b = internal_1.parser(tokens_copy, b, seen_copy, stall_fn);
            parse_d = delim ? internal_1.parser(tokens_copy, delim, seen_copy, stall_fn) : [];
            parse_a = internal_1.parser(tokens_copy, a, seen_copy, stall_fn);
            if (parse_b && parse_d && parse_a) {
                tokens.splice(0, tokens.length - tokens_copy.length);
                seen.push(...seen_copy.slice(seen.length));
                return [].concat(parse_b, parse_d, parse_a);
            }
            return null;
        },
    };
}
exports.swappable = swappable;
