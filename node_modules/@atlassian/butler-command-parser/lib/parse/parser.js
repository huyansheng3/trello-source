"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parser = void 0;
const assert_1 = __importDefault(require("assert"));
const globals_1 = require("../globals");
const internal_1 = require("./internal");
function printSeen(seen) {
    return `(${seen.join(', ')})`;
}
function printRule(rule) {
    switch (typeof rule) {
        case 'string':
            return rule;
        case 'object':
            if (Array.isArray(rule)) {
                return `[${rule
                    .map(function (r) {
                    return printRule(r);
                })
                    .join(', ')}]`;
            }
            if (typeof rule.parse === 'function') {
                return `${rule.parse.name}()`;
            }
            return `expecting_function(${JSON.stringify(rule)})`;
        default:
            return `invalid_type_for_rule(${JSON.stringify(rule)})`;
    }
}
function lsplit(string, separator, limit) {
    const split = string.split(separator);
    return limit && limit < split.length
        ? split.slice(0, limit).concat([split.slice(limit).join(separator)])
        : split;
}
function rsplit(string, separator, limit) {
    const split = string.split(separator);
    return limit && limit < split.length
        ? [split.slice(0, -limit).join(separator)].concat(split.slice(-limit))
        : split;
}
function parser(tokens, rule, seen, stall_fn) {
    if (globals_1.DEBUG) {
        globals_1.Logger.info('parser', {
            numTokens: tokens.length,
            firstToken: tokens.length && tokens[0],
            seen: printSeen(seen),
            rule: printRule(rule),
        });
    }
    switch (typeof rule) {
        case 'string': {
            if (internal_1.isEnd(rule)) {
                return !tokens.length ? rule : stall_fn(tokens, null);
            }
            if (internal_1.isInlineEnd(rule)) {
                return rule;
            }
            if (internal_1.isOptional(rule)) {
                return internal_1.optional(internal_1.getOptional(rule)).parse(tokens, seen, stall_fn);
            }
            if (internal_1.isStringVariable(rule)) {
                if (!tokens[0] || tokens[0][0] !== '"') {
                    return stall_fn(tokens, 'quoted text, e.g. "Name"');
                }
                const parsed = {};
                parsed[rule] = tokens.shift();
                return parsed;
            }
            if (internal_1.isVariableName(rule)) {
                if (!tokens[0] || !internal_1.isVariableNameValue(tokens[0])) {
                    return stall_fn(tokens, 'a variable name, e.g. {{name}}');
                }
                const parsed = {};
                parsed[rule.slice(1, -1)] = tokens.shift();
                return parsed;
            }
            if (internal_1.isAtMention(rule)) {
                if (!tokens[0] || tokens[0][0] !== '@') {
                    return stall_fn(tokens, 'a mention, e.g. @username');
                }
                const parsed = {};
                parsed[rule] = tokens.shift();
                return parsed;
            }
            if (internal_1.isTerminal(rule)) {
                return tokens[0] === rule ? tokens.shift() : stall_fn(tokens, rule);
            }
            const conditional = lsplit(rule, '?', 1);
            if (conditional.length > 1) {
                const condition = conditional[0];
                const clause = rsplit(conditional[1], ':');
                const _then = clause[0];
                const _else = clause[1];
                assert_1.default(internal_1.isSymbol(condition), `Not a symbol: ${condition} in conditional ${rule}`);
                const found = seen.indexOf(condition) !== -1;
                if (globals_1.DEBUG) {
                    globals_1.Logger.info('conditional', { rule, found });
                }
                if (found) {
                    return parser(tokens, _then, seen, stall_fn);
                }
                if (_else) {
                    return parser(tokens, _else, seen, stall_fn);
                }
                return null;
            }
            let symbol;
            const rewrite = rule.split('=>');
            if (rewrite.length === 2 && internal_1.isSymbol(rewrite[0]) && internal_1.isSymbol(rewrite[1])) {
                symbol = rewrite[1];
                rule = internal_1.getCommandGrammar()[rewrite[0]];
            }
            else {
                assert_1.default(internal_1.isSymbol(rule), `Not a symbol: ${rule}`);
                symbol = rule;
                rule = internal_1.getCommandGrammar()[symbol];
            }
            if (!rule) {
                assert_1.default(false, `Symbol '${symbol}' not found.`);
                return null;
            }
            const parsed = {};
            parsed[symbol] = parser(tokens, rule, seen, stall_fn);
            if (parsed[symbol] === null) {
                if (globals_1.DEBUG) {
                    globals_1.Logger.info('-prune', {
                        numTokens: tokens.length,
                        firstToken: tokens.length && tokens[0],
                        seen: printSeen(seen),
                        symbol,
                        rule: printRule(rule),
                    });
                }
                return null;
            }
            if (globals_1.DEBUG) {
                globals_1.Logger.info('+accept', {
                    numTokens: tokens.length,
                    firstToken: tokens.length && tokens[0],
                    seen: printSeen(seen),
                    symbol,
                    rule: printRule(rule),
                });
            }
            seen.push(symbol);
            return parsed;
        }
        case 'object':
            if (Array.isArray(rule)) {
                const tokens_copy = tokens.slice();
                const seen_copy = seen.slice();
                const parses = [];
                for (let i = 0; i < rule.length; ++i) {
                    const parsed = parser(tokens_copy, rule[i], seen_copy, stall_fn);
                    if (parsed === null) {
                        return null;
                    }
                    parses.push(parsed);
                }
                tokens.splice(0, tokens.length - tokens_copy.length);
                seen.push(...seen_copy.slice(seen.length));
                return parses;
            }
            assert_1.default(typeof rule.parse === 'function', `Cannot handle rule: ${JSON.stringify(rule)}`);
            return rule.parse(tokens, seen, stall_fn);
        default:
            assert_1.default(false, `Cannot handle rule: ${JSON.stringify(rule)}`);
            return stall_fn(tokens, '(internal error)');
    }
}
exports.parser = parser;
