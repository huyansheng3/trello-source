import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import _taggedTemplateLiteral from "@babel/runtime/helpers/taggedTemplateLiteral";

var _templateObject, _templateObject2;

import React from 'react';
import styled from 'styled-components'; // AFP-2532 TODO: Fix automatic suppressions below
// eslint-disable-next-line @atlassian/tangerine/import/entry-points

import { colors, elevation, gridSize } from '@atlaskit/theme';
import BaseAtlaskitIcon from '@atlaskit/icon';
import { ImageLoadedTracker } from './analytics';
export var IconBase = styled.div(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  width: ", "px;\n  height: ", "px;\n  border-radius: ", "px;\n  ", ";\n  background-color: ", ";\n  overflow: hidden;\n"])), 4 * gridSize(), 4 * gridSize(), gridSize(), function (_ref) {
  var iconElevation = _ref.iconElevation;
  return iconElevation ? iconElevation : '';
}, function (_ref2) {
  var bgColor = _ref2.bgColor;
  return bgColor;
});
var ImageIconBase = styled(ImageLoadedTracker)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n  width: ", "px;\n  height: ", "px;\n"])), gridSize() * 3, gridSize() * 3);
export var themes = {
  default: {
    backgroundColor: '#fff',
    primaryColor: '#000',
    iconElevation: elevation.e100
  },
  product: {
    iconColor: colors.N0,
    backgroundColor: colors.B400,
    primaryColor: colors.N0,
    iconElevation: elevation.e100
  },
  admin: {
    backgroundColor: colors.DN70,
    primaryColor: colors.N0,
    iconElevation: elevation.e100
  },
  custom: {
    backgroundColor: colors.N0,
    primaryColor: colors.DN70,
    iconElevation: elevation.e100
  },
  subtle: {
    backgroundColor: 'transparent',
    primaryColor: colors.text
  },
  recommendedProduct: {
    backgroundColor: colors.N30,
    iconColor: colors.B200,
    iconGradientStart: colors.B400,
    iconGradientStop: colors.B200,
    iconElevation: elevation.e100
  },
  recentLinks: {
    backgroundColor: '#fff',
    primaryColor: '#000'
  },
  discover: {
    backgroundColor: colors.N30,
    primaryColor: colors.DN90,
    iconElevation: elevation.e100
  }
};
export var createIcon = function createIcon(InnerIcon, defaultProps) {
  return function (props) {
    var _ref3 = themes[props.theme] || themes.default,
        backgroundColor = _ref3.backgroundColor,
        iconElevation = _ref3.iconElevation,
        iconProps = _objectWithoutProperties(_ref3, ["backgroundColor", "iconElevation"]);

    return /*#__PURE__*/React.createElement(IconBase, {
      bgColor: backgroundColor,
      iconElevation: iconElevation
    }, /*#__PURE__*/React.createElement(InnerIcon, _extends({}, defaultProps, iconProps)));
  };
};
export var createImageIcon = function createImageIcon(url) {
  return function (props) {
    var _ref4 = themes[props.theme] || themes.default,
        backgroundColor = _ref4.backgroundColor,
        iconElevation = _ref4.iconElevation;

    return /*#__PURE__*/React.createElement(IconBase, {
      bgColor: backgroundColor,
      iconElevation: iconElevation
    }, /*#__PURE__*/React.createElement(ImageIconBase, {
      src: url
    }));
  };
};
export var createThemedImageIcon = function createThemedImageIcon(iconUrlsByTheme) {
  return function (props) {
    var iconUrl = iconUrlsByTheme[props.theme] || iconUrlsByTheme.default;
    var ImageIcon = React.useMemo(function () {
      return createImageIcon(iconUrl);
    }, [iconUrl]);
    return /*#__PURE__*/React.createElement(ImageIcon, props);
  };
};
/**
 * Due to remote SVG's downloading through fetch, there is a delay between when the network request starts and when they are rendered.
 * This causes them to disappear each time Switcher is mounted.
 * Adding this cache means that we can store the SVG content between mounts and not need to worry about re-fetching the content.
 */

var svgCache = {};

var RemoteIcon = function RemoteIcon(props) {
  var url = props.url,
      svgProps = _objectWithoutProperties(props, ["url"]);

  var _React$useState = React.useState(svgCache[url]),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      svg = _React$useState2[0],
      setSvg = _React$useState2[1];

  React.useEffect(function () {
    if (!svgCache[url]) {
      fetch(url).then(function (res) {
        return res.text();
      }).then(function (content) {
        setSvg(content);
        svgCache[url] = content;
      });
    }
  }, [url]);

  var BaseIcon = function BaseIcon(iconProps) {
    return /*#__PURE__*/React.createElement(BaseAtlaskitIcon, _extends({}, iconProps, {
      label: "Settings",
      dangerouslySetGlyph: svg
    }));
  };

  var Icon = createIcon(BaseIcon);
  return /*#__PURE__*/React.createElement(Icon, svgProps);
};

export var createRemoteIcon = function createRemoteIcon(url, svgProps) {
  return function (props) {
    return /*#__PURE__*/React.createElement(RemoteIcon, _extends({
      url: url
    }, svgProps, props));
  };
};