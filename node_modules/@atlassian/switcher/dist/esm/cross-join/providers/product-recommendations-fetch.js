import _regeneratorRuntime from "@babel/runtime/regenerator";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _defineProperty from "@babel/runtime/helpers/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import { ProductKey } from '../../types';
import { enrichFetchError } from '../../common/utils/fetch';
/* Joinable Sites API was replaced by Product Recommendations API as part of productionizing the Joinable Sites
   experimental API. This code maps Product Recommendations API results into Joinable Sites API results for
   compatibility with existing UI elements.
 */

/* We are supporting services supplying this endpoint: id-invidations for Trello aa-mastered users and
 * experiment-api for Trello non-aa-masterered users. The consuming component supplies the base url for
 * the service based on local context.
 *
 * We expect to drop support for Trello non-aa-mastered users in FY22. At this point we expect to define the
 * sole service host here.
 */

var productRecommendationsUrl = function productRecommendationsUrl(baseUrl) {
  return baseUrl + '/v1/product-recommendations' + // Query parameters are optional filters. All results are returned by default.
  '?capability=DIRECT_ACCESS' + // Subsequent conditions are prefaced with '&'
  // i.e. + '&product=confluence'
  '&product=jira-software&product=jira-servicedesk&product=jira-core&product=confluence';
};

// tenantedProducts and nonTenantedProducts used to identify which ARIs contain cloudId
// Also used to convert resourceOwner strings to JoinableSites product strings
// ARI resource-owners whose resource-type == 'site' do set resource-id to {cloudId}
// See https://developer.atlassian.com/platform/atlassian-resource-identifier/resource-owners/registry/
var tenantedProducts = {
  confluence: ProductKey.CONFLUENCE,
  // 'jira': ???, // 'jira' is a valid tenanted ARI, but it is not used downstream and its presence may cause a bug
  'jira-core': ProductKey.JIRA_CORE,
  'jira-servicedesk': ProductKey.JIRA_SERVICE_DESK,
  'jira-software': ProductKey.JIRA_SOFTWARE,
  opsgenie: ProductKey.OPSGENIE,
  // 'platform': ???, // 'platform' is a valid tenanted ARI, but it is not used downstream and its presence may cause a bug
  statuspage: ProductKey.STATUSPAGE
}; // The ARI resource-owners whose resource-type == 'site' do NOT set resource-id to {cloudId} (typically set to a constant
// string of their resource-owner name, e.g. resource-owner is Trello, then resource-id is 'trello')

/* Not used, commented to avoid linting error
const nonTenantedProducts: {[key: string]: string}  = {
  'bitbucket': ProductKey.BITBUCKET,
  'trello': ProductKey.TRELLO,
}
*/

var convertProductRecommendationsResponseToJoinableSitesResponse = function convertProductRecommendationsResponseToJoinableSitesResponse(input) {
  /*
    JoinableSitesResponse shape
    {
      sites: [
        {
          // JoinableSites type
          cloudId: string
          url: string
          displayName: string
          avatarUrl?: string
          relevance?: string
          // At least one of: 'products', 'users'. We always use 'products' here.
          products: // Undefined OR Array of JoinableProductDetails OR array array of string. We always use Array of JoinableProductDetails here.
            [
              collaborators: [ // Collaborators is empty. Neither Joinable-Sites(old) or Product-Recommendations(new) can supply them
                avatarUrl: string;
                displayName: string;
                relevance?: number;
              ];
              productUrl: string;
            ]
            // OR
            [
              string[]
            ]
          users: [
            avatarUrl: string;
            displayName: string;
            relevance?: number;
          ]
        }
      ]
    }
   */

  /* Intermediate representation for holding parsed input data. As we are only returning results for tenanted products,
   * this uses cloudId as the key. Associative array used since order of cloudIds is unknown. product-recommendations
   * returns a (flat) list of all products for possibly many cloudIds, both of which are encoded in the ARI. This
   * unflattens the list, sorting the products by the cloudId as required by the JoinableSitesResponse data structure.
   */
  var sites = {};
  input.capability.DIRECT_ACCESS.forEach(function (inputResource, index) {
    var ari = parseAri(inputResource.resourceId);

    if (tenantedProducts[ari.resourceOwner] && ari.resourceType === 'site') {
      if (ari.resourceId in sites) {
        // Update this site with the new product
        // @ts-ignore Initializer branch assumes products is an array of JoinableProductDetails
        sites[ari.resourceId].products[tenantedProducts[ari.resourceOwner]] = {
          collaborators: [],
          productUrl: inputResource.url
        };
      } else {
        // Add site with this product
        var url = new URL(inputResource.url);
        var products = {};
        products[tenantedProducts[ari.resourceOwner]] = {
          collaborators: [],
          // product-recommendations cannot provide collaborators. Collaborators are not used as of 2021 Jan
          productUrl: inputResource.url
        };
        sites[ari.resourceId] = {
          cloudId: ari.resourceId,
          url: url.origin,
          displayName: inputResource.displayName,
          products: products,
          relevance: Math.max(1000 - index, 0)
        };
      }
    }
  }); // Place sites into Array as required by JoinableSitesResponse

  var sitesArray = [];

  for (var cloudId in sites) {
    sitesArray.push(sites[cloudId]);
  }

  return {
    sites: sitesArray
  };
};

var parseAri = function parseAri(input) {
  /* Valid ARI: https://developer.atlassian.com/platform/atlassian-resource-identifier/spec/ari-latest/#syntax
   * ari:cloud:<resource_owner>::<resource_type>/<resource_id>
   * ari:cloud:<resource_owner>:<cloud_id>:<resource_type>/<resource_id>
   */
  var colonSplitInput = input.split(':');

  if (colonSplitInput.length !== 5 || colonSplitInput[0] !== 'ari' || colonSplitInput[1] !== 'cloud') {
    // Not a valid ARI https://developer.atlassian.com/platform/atlassian-resource-identifier/spec/ari-latest/#syntax
    // as of 2021 Jan
    throw new Error('Invalid ARI');
  }

  var slashSplitInput = colonSplitInput[4].split('/');

  if (slashSplitInput.length !== 2) {
    // Not a valid ARI https://developer.atlassian.com/platform/atlassian-resource-identifier/spec/ari-latest/#syntax
    // as of 2021 Jan
    throw new Error('Invalid ARI');
  }

  return {
    uriScheme: colonSplitInput[0],
    cloud: colonSplitInput[1],
    resourceOwner: colonSplitInput[2],
    // For back-compatibility with Jira and Confluence. May be empty
    cloudId: colonSplitInput[3],
    resourceType: slashSplitInput[0],
    resourceId: slashSplitInput[1]
  };
};

var isPublicEmailDomainError = function isPublicEmailDomainError(body) {
  // Public Email Domain Error returns a body with the following content:
  // {"code":"email-public-domain","message":"Request requires a domain which is not public"}
  return (body === null || body === void 0 ? void 0 : body.code) && body.code === 'email-public-domain';
};

var emptyProductRecommendationResponse = {
  capability: {
    DIRECT_ACCESS: [],
    REQUEST_ACCESS: []
  }
};
/* We are unable to use fetchJson from packages/navigation/atlassian-switcher/src/common/utils/fetch.ts
 * because some 400 errors from productRecommendation API are expected and should be handled as empty data
 */

export var fetchJsonOrEmptyProductRecommendationsResponse = function fetchJsonOrEmptyProductRecommendationsResponse(url, init) {
  return fetch(url, _objectSpread({
    credentials: 'include'
  }, init)).then( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(response) {
      var jsonPromise, json;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              jsonPromise = response.json();

              if (!response.ok) {
                _context.next = 3;
                break;
              }

              return _context.abrupt("return", jsonPromise);

            case 3:
              if (!(response.status === 400)) {
                _context.next = 9;
                break;
              }

              _context.next = 6;
              return jsonPromise;

            case 6:
              json = _context.sent;

              if (!isPublicEmailDomainError(json)) {
                _context.next = 9;
                break;
              }

              return _context.abrupt("return", emptyProductRecommendationResponse);

            case 9:
              throw enrichFetchError(new Error("Unable to fetch ".concat(url, " ").concat(response.status, " ").concat(response.statusText)), response.status);

            case 10:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }());
};
export var fetchProductRecommendationsInternal = function fetchProductRecommendationsInternal() {
  var baseUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return fetchJsonOrEmptyProductRecommendationsResponse(productRecommendationsUrl(baseUrl), {
    method: 'get'
  }).then(function (response) {
    return convertProductRecommendationsResponseToJoinableSitesResponse(response);
  });
};
export var fetchProductRecommendations = function fetchProductRecommendations(baseUrl) {
  return function () {
    return fetchProductRecommendationsInternal(baseUrl);
  };
};