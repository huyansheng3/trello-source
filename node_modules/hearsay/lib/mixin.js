var Slot, hasProp, remember, subscribeChanges, uniqueKey, watch;

uniqueKey = require('./utils/uniqueKey');

watch = require('./watch');

subscribeChanges = require('./methods/subscribe-changes');

Slot = require('./slot');

hasProp = function(obj, prop) {
  return Object.hasOwnProperty.call(obj, prop);
};

remember = function(target, unsubscribe) {
  var key, observationSet;
  observationSet = (target._hearsay_subscriptions != null ? target._hearsay_subscriptions : target._hearsay_subscriptions = {});
  key = uniqueKey();
  observationSet[key] = unsubscribe;
  return function() {
    unsubscribe();
    return delete observationSet[key];
  };
};

module.exports = {
  subscribe: function(signal, callback) {
    return remember(this, signal.subscribe(callback, this));
  },
  using: function(signal) {
    if (this._hearsay_using == null) {
      this._hearsay_using = [];
    }
    this._hearsay_using.push(signal.use());
    return signal;
  },
  slot: function(val) {
    return this.using(new Slot(val));
  },
  subscribeChanges: function(signal, callbacks) {
    return remember(this, subscribeChanges.call(signal, callbacks, this));
  },
  watch: function(target, path, callback) {
    if (arguments.length === 2) {
      callback = path;
      path = target;
      target = this;
    }
    return remember(this, watch(target, path, callback, this));
  },
  unsubscribe: function() {
    var key, ref, unsubscribe;
    if (!hasProp(this, '_hearsay_subscriptions')) {
      return;
    }
    ref = this._hearsay_subscriptions;
    for (key in ref) {
      unsubscribe = ref[key];
      unsubscribe();
    }
    delete this._hearsay_subscriptions;
  },
  stopUsing: function() {
    var i, len, ref, stopUsing;
    if (!hasProp(this, '_hearsay_using')) {
      return;
    }
    ref = this._hearsay_using;
    for (i = 0, len = ref.length; i < len; i++) {
      stopUsing = ref[i];
      stopUsing();
    }
    delete this._hearsay_using;
  }
};
