var Signal, dispose, eligibleSignals, isDisposalScheduled, once, schedulerRef, uniqueKey;

uniqueKey = require('./utils/uniqueKey');

once = require('./utils/once');

schedulerRef = require('./scheduler-ref');

eligibleSignals = [];

isDisposalScheduled = false;

dispose = function() {
  var i, signal;
  i = 0;
  while (i < eligibleSignals.length) {
    signal = eligibleSignals[i];
    signal._scheduled = false;
    if (signal._users === 0) {
      signal._dispose();
    }
    i++;
  }
  eligibleSignals = [];
  isDisposalScheduled = false;
};

module.exports = Signal = (function() {
  Signal.prototype._users = 0;

  Signal.prototype._disposed = false;

  Signal.prototype._scheduled = false;

  function Signal(source) {
    this._disposers = [source(this._send.bind(this))];
    this._subscriptions = {};
    this._schedule();
  }

  Signal.prototype._send = function(val) {
    var context, fn, key, ref, ref1;
    if (this._disposed) {
      throw new Error("Signal cannot send events after disposal. (Did you forget to return a disposer?)");
    }
    ref = this._subscriptions;
    for (key in ref) {
      ref1 = ref[key], fn = ref1[0], context = ref1[1];
      fn.call(context, val);
    }
  };

  Signal.prototype._schedule = function() {
    if (this._scheduled) {
      return;
    }
    this._scheduled = true;
    eligibleSignals.push(this);
    if (isDisposalScheduled) {
      return;
    }
    schedulerRef.schedule(dispose);
    isDisposalScheduled = true;
  };

  Signal.prototype._dispose = function() {
    var disposer, j, len, ref;
    this._disposed = true;
    ref = this._disposers;
    for (j = 0, len = ref.length; j < len; j++) {
      disposer = ref[j];
      if (typeof disposer !== 'undefined') {
        disposer();
      }
    }
    delete this._disposers;
  };

  Signal.prototype.subscribe = function(fn, context) {
    var key, unuse, watchers;
    watchers = this._subscriptions;
    key = uniqueKey();
    watchers[key] = [fn, context];
    unuse = this.use();
    return once('Cannot "unsubscribe" more than once!', function() {
      delete watchers[key];
      unuse();
    });
  };

  Signal.prototype.use = function() {
    if (this._disposed) {
      throw new Error("Cannot use a signal after it has been disposed.");
    }
    this._users++;
    return once('Cannot "unuse" more than once!', (function(_this) {
      return function() {
        _this._users--;
        if (_this._users === 0) {
          _this._schedule();
        }
      };
    })(this));
  };

  Signal.prototype.derive = function(source) {
    var unuse;
    unuse = this.use();
    return new this.derivedType(function(send) {
      var disposeInner;
      disposeInner = source(send);
      return function() {
        disposeInner();
        return unuse();
      };
    });
  };

  Signal.prototype.addDisposer = function(disposer) {
    if (this._disposed) {
      throw new Error("Cannot add a disposer to a disposed signal.");
    }
    this._disposers.push(disposer);
    return this;
  };

  Signal.prototype.derivedType = Signal;

  return Signal;

})();
