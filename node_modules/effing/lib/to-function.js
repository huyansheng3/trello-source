var isArray, isFunction, isString, noop, toFunction, _ref,
  __slice = [].slice;

noop = function() {};

isArray = (_ref = Array.isArray) != null ? _ref : function(x) {
  return Object.prototype.toString.call(x) === '[object Array]';
};

isFunction = function(x) {
  return typeof x === 'function';
};

isString = function(x) {
  return typeof x === 'string';
};

toFunction = function() {
  var args, fn, functionoid, method, target;
  functionoid = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  if (functionoid.length === 0) {
    return noop;
  }
  if (functionoid[0] == null) {
    return noop;
  }
  if (typeof functionoid[0] === 'function') {
    fn = functionoid[0], args = 2 <= functionoid.length ? __slice.call(functionoid, 1) : [];
    if (args.length === 0) {
      return fn;
    } else {
      return function() {
        return fn.call.apply(fn, [this].concat(__slice.call(args), __slice.call(arguments)));
      };
    }
  }
  target = functionoid[0], method = functionoid[1], args = 3 <= functionoid.length ? __slice.call(functionoid, 2) : [];
  fn = (function() {
    if (isString(method)) {
      return target[method];
    } else if (isFunction(method)) {
      return method;
    } else {
      throw new Error("The [target, method, args...] functionoid requires a string or a function as the method");
    }
  })();
  return function() {
    return fn.call.apply(fn, [target].concat(__slice.call(args), __slice.call(arguments)));
  };
};

module.exports = toFunction;
