var f, prime,
  __slice = [].slice;

f = require('./to-function');

prime = require('./prime');

module.exports = {
  noop: f(),
  id: function(a) {
    return a;
  },
  choke: function() {
    var fn, fnArgs, length;
    length = arguments[0], fnArgs = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    fn = f.apply(null, fnArgs);
    return function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return fn.apply(this, args.slice(0, length));
    };
  },
  concat: function() {
    var fns;
    fns = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return function() {
      var fn, val, _i, _len;
      val = void 0;
      for (_i = 0, _len = fns.length; _i < _len; _i++) {
        fn = fns[_i];
        val = fn.apply(this, arguments);
      }
      return val;
    };
  },
  compose: function(a, b) {
    return function() {
      return a.call(this, b.apply(this, arguments));
    };
  },
  unpack: function(fn) {
    return function(arg) {
      return fn.apply(this, arg);
    };
  },
  invoke: function() {
    var args, f;
    f = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return f.apply(this, args);
  },
  guard: function(fn, pred, elseValue) {
    return function() {
      if (pred.apply(this, arguments)) {
        return fn.apply(this, arguments);
      } else {
        return elseValue;
      }
    };
  },
  "const": function(val) {
    return function() {
      return val;
    };
  },
  once: function(fn, errorMessage) {
    if (errorMessage == null) {
      errorMessage = "Function called more than once!";
    }
    return prime({
      first: fn,
      after: function() {
        throw new Error(errorMessage);
      }
    });
  }
};
