var biggestSmallerThanOrEqualTo,
  __hasProp = {}.hasOwnProperty;

biggestSmallerThanOrEqualTo = function(list, target) {
  var smaller;
  smaller = list.filter(function(x) {
    return x <= target;
  });
  if (smaller.length === 0) {
    return null;
  }
  return Math.max.apply(null, smaller);
};

module.exports = function(originalMap) {
  var key, map, num, nums, val;
  if (arguments.length !== 1) {
    throw new Error("overloaded is not overloaded!");
  }
  map = {};
  nums = (function() {
    var _results;
    _results = [];
    for (key in originalMap) {
      if (!__hasProp.call(originalMap, key)) continue;
      val = originalMap[key];
      num = Number(key);
      if (key === '' || isNaN(num)) {
        throw new Error("non-numeric key " + key);
      }
      map[num] = val;
      _results.push(num);
    }
    return _results;
  })();
  if (nums.length === 0) {
    throw new Error("you must pass at least one overload!");
  }
  return function() {
    var fn, len, _ref;
    len = arguments.length;
    fn = (_ref = map[len]) != null ? _ref : (function() {
      len = biggestSmallerThanOrEqualTo(nums, len);
      if (len === null) {
        throw new Error("function not overloaded to accept " + arguments.length + " arguments");
      }
      return map[len];
    })();
    return fn.apply(this, arguments);
  };
};
