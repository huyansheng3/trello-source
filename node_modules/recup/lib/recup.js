// Generated by CoffeeScript 1.9.3
(function() {
  var React, Recup, els, fn, i, len, ref, tagName,
    slice = [].slice;

  React = require('react');

  els = require('./elements');

  Recup = (function() {
    function Recup() {
      this.elementsOut = null;
    }

    Recup.prototype.resetBuffer = function(elements) {
      var previous;
      if (elements == null) {
        elements = null;
      }
      previous = this.elementsOut;
      this.elementsOut = elements;
      return previous;
    };

    Recup.prototype._render = function() {
      var args, context, previous, result, template;
      template = arguments[0], context = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];
      previous = this.resetBuffer([]);
      try {
        template.apply(context, args);
      } finally {
        result = this.resetBuffer(previous);
      }
      return result;
    };

    Recup.prototype._unwrap = function(nodes) {
      if (nodes.length !== 1) {
        throw Error("template must have exactly one top-level node");
      }
      return nodes[0];
    };

    Recup.prototype.render = function() {
      var args, template;
      template = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      return this._unwrap(this._render.apply(this, [template, null].concat(slice.call(args))));
    };

    Recup.prototype.cede = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return this.render.apply(this, args);
    };

    Recup.prototype.renderable = function(template) {
      var t;
      t = this;
      return function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        if (t.elementsOut === null) {
          return t._unwrap(t._render.apply(t, [template, this].concat(slice.call(args))));
        } else {
          return template.apply(this, args);
        }
      };
    };

    Recup.prototype.renderAttr = function() {};

    Recup.prototype.isSelector = function(str) {
      var ref;
      return str.length > 1 && ((ref = str.charAt(0)) === '#' || ref === '.');
    };

    Recup.prototype.parseSelector = function(sel) {
      var classes, i, id, klass, len, ref, ref1, token;
      id = null;
      classes = [];
      ref = sel.split('.');
      for (i = 0, len = ref.length; i < len; i++) {
        token = ref[i];
        token = token.trim();
        if (id) {
          classes.push(token);
        } else {
          ref1 = token.split('#'), klass = ref1[0], id = ref1[1];
          if (klass) {
            classes.push(klass);
          }
        }
      }
      return {
        id: id,
        classes: classes
      };
    };

    Recup.prototype._unNestData = function(prefix, data) {
      var k, nK, nV, obj, ref, v;
      obj = {};
      if (typeof data === 'object') {
        for (k in data) {
          v = data[k];
          ref = this._unNestData([prefix, k].join('-'), v);
          for (nK in ref) {
            nV = ref[nK];
            obj[nK] = nV;
          }
        }
      } else {
        obj[prefix] = data;
      }
      return obj;
    };

    Recup.prototype.normalizeArgs = function(args) {
      var arg, attrs, classes, contents, data, i, id, index, k, len, ref, ref1, selector, v;
      attrs = {};
      selector = null;
      contents = null;
      for (index = i = 0, len = args.length; i < len; index = ++i) {
        arg = args[index];
        if (arg != null) {
          switch (typeof arg) {
            case 'string':
              if (index === 0 && this.isSelector(arg)) {
                selector = arg;
              } else {
                throw Error('Only pass strings that are selectors', {
                  arg: arg
                });
              }
              break;
            case 'object':
              if (arg.constructor === Object) {
                attrs = arg;
              } else {
                throw Error('Only pass simple objects', {
                  arg: arg
                });
              }
              break;
            case 'function':
              contents = arg;
              break;
            default:
              throw Error('Unrecognized argument type', {
                arg: arg
              });
          }
        }
      }
      if (attrs["class"] != null) {
        if (attrs.className != null) {
          throw Error("Can't specify both class and className");
        }
        attrs.className = attrs["class"];
        delete attrs["class"];
      }
      if (attrs.data != null) {
        data = attrs.data;
        delete attrs.data;
        ref = this._unNestData('data', data);
        for (k in ref) {
          v = ref[k];
          attrs[k] = v;
        }
      }
      if (selector != null) {
        ref1 = this.parseSelector(selector), id = ref1.id, classes = ref1.classes;
        if (id != null) {
          attrs.id = id;
        }
        if (classes.length) {
          if (attrs.className) {
            classes.push(attrs.className);
          }
          attrs.className = classes.join(' ');
        }
      }
      return {
        attrs: attrs,
        contents: contents
      };
    };

    Recup.prototype.renderChildren = function(contents) {
      if (contents == null) {
        return [];
      } else if (typeof contents === 'function') {
        return this._render(contents);
      } else {
        throw Error('Unrecognized contents type', {
          contents: contents
        });
      }
    };

    Recup.prototype.createElement = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return this.elementsOut.push(React.createElement.apply(React, args));
    };

    Recup.prototype.addElement = function(el) {
      return this.elementsOut.push(el);
    };

    Recup.prototype.tag = function() {
      var args, attrs, children, contents, ref, tagName;
      tagName = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      ref = this.normalizeArgs(args), attrs = ref.attrs, contents = ref.contents;
      children = this.renderChildren(contents);
      return this.elementsOut.push(React.createElement.apply(React, [tagName, attrs].concat(slice.call(children))));
    };

    Recup.prototype.text = function(str) {
      return this.elementsOut.push(str.toString());
    };

    Recup.prototype.raw = function(str) {
      return this.span({
        dangerouslySetInnerHTML: {
          __html: str
        }
      });
    };

    Recup.prototype.bound = function() {
      var bound, boundMethods, fn, i, len, method, ref;
      bound = {};
      boundMethods = 'cede raw render renderable tag text addElement createElement normalizeArgs'.split(' ');
      ref = boundMethods.concat(els.regular, els["void"], els.obsolete, els.obsolete_void);
      fn = (function(_this) {
        return function(method) {
          return bound[method] = function() {
            var args;
            args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            return _this[method].apply(_this, args);
          };
        };
      })(this);
      for (i = 0, len = ref.length; i < len; i++) {
        method = ref[i];
        fn(method);
      }
      return bound;
    };

    return Recup;

  })();

  ref = els.regular.concat(els["void"], els.obsolete, els.obsolete_void);
  fn = function(tagName) {
    return Recup.prototype[tagName] = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return this.tag.apply(this, [tagName].concat(slice.call(args)));
    };
  };
  for (i = 0, len = ref.length; i < len; i++) {
    tagName = ref[i];
    fn(tagName);
  }

  module.exports = new Recup().bound();

  module.exports.Recup = Recup;

}).call(this);
