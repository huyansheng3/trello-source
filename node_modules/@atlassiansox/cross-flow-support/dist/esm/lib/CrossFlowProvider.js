import _extends from "@babel/runtime/helpers/extends";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import React, { Suspense, useCallback, useMemo, useState, useRef } from 'react';
import { BaseCrossFlowApiProvider, Journeys } from '@atlassiansox/cross-flow-api-internals';
import { analyticsWrapper } from './analytics-helpers/analyticsHelpers';
import { transformEvent } from './analytics-helpers/analyticsTransformers';
import { setProductSignUpLocation } from './redirects-helpers/redirectsHelpers';
import { ErrorBoundary } from './errorBoundary';
import { enrichWithPackageDetails } from './enrichWithPackageDetails';
import { enrichWithRequestOptions } from './enrichWithRequestOptions';
import { OPERATIONAL_EVENT_TYPE, source, uiInitialized, crossFlowActionSubject, openInvoked } from './constants';
var IntegrationView = /*#__PURE__*/React.lazy(function () {
  return import(
  /* webpackChunkName: "atlassiansox-cross-flow-support-deferred" */

  /* webpackPrefetch: true */
  './view');
});

/**
 * Generic Cross Flow API provider.
 *
 * Initializes Cross Flow support in product.
 * Renders Cross Flow overlay when requested via context API.
 */
export var createCrossFlowProvider = function createCrossFlowProvider(IntegrationView) {
  return function (props) {
    var children = props.children,
        analyticsClient = props.analyticsClient,
        originProduct = props.originProduct,
        redirectToWac = props.redirectToWac,
        env = props.env,
        _props$plugins = props.plugins,
        plugins = _props$plugins === void 0 ? [] : _props$plugins,
        onError = props.onError,
        baseProviderProps = _objectWithoutProperties(props, ["children", "analyticsClient", "originProduct", "redirectToWac", "env", "plugins", "onError"]);

    var onCloseResolver = useRef();

    var _useState = useState(false),
        _useState2 = _slicedToArray(_useState, 2),
        firstHandshakeReceived = _useState2[0],
        setFirstHandshakeReceived = _useState2[1];

    var fireEvent = useMemo(function () {
      return analyticsWrapper(analyticsClient);
    }, [analyticsClient]);

    var _useState3 = useState(),
        _useState4 = _slicedToArray(_useState3, 2),
        requestOptions = _useState4[0],
        setRequestOptions = _useState4[1];

    var onAnalyticsEvent = useCallback(function (payload) {
      var gasV3Event = transformEvent(payload);

      if (gasV3Event) {
        var enrichedEvent = enrichWithRequestOptions(enrichWithPackageDetails(gasV3Event), requestOptions);
        fireEvent(enrichedEvent);
      }
    }, [fireEvent, requestOptions]);
    var onHandShake = useCallback(function (appName) {
      if (!firstHandshakeReceived) {
        onAnalyticsEvent({
          payload: {
            eventType: OPERATIONAL_EVENT_TYPE,
            action: uiInitialized,
            actionSubject: crossFlowActionSubject,
            attributes: {
              appName: appName
            }
          },
          context: [{
            source: source
          }]
        });
        setFirstHandshakeReceived(true);
      }
    }, [firstHandshakeReceived, onAnalyticsEvent]);
    var onOpen = useCallback(function (options) {
      /**
       * Reset first handshake state to ensure 1:1 value of open invoked and handshake received
       * Caveat that if open api is invoked while cross flow support UI is already mounted there will be mismatch of openInvoked events to uiInitialized events
       */
      setFirstHandshakeReceived(false);
      var analyticsEvent = {
        // setRequestOptions does not update the state right away (updates on the next render) so for the openInvoked event we need to manually append the sourceComponent and sourceContext
        payload: enrichWithRequestOptions({
          eventType: OPERATIONAL_EVENT_TYPE,
          action: openInvoked,
          actionSubject: crossFlowActionSubject
        }, options),
        context: [{
          source: source
        }]
      };
      onAnalyticsEvent(analyticsEvent); // Short circuit requestOptions for WAC expansions

      if (options.journey === Journeys.GET_STARTED && redirectToWac) {
        setProductSignUpLocation(options.targetProduct, env, options.sourceComponent, options.sourceContext);
        var _completionStatus = {};
        return Promise.resolve(_completionStatus);
      }

      setRequestOptions(options);
      return new Promise(function (resolve) {
        onCloseResolver.current = resolve;
      });
    }, [onAnalyticsEvent, env, redirectToWac]);
    var onClose = useCallback(function (completionStatus) {
      setFirstHandshakeReceived(false);
      setRequestOptions(undefined);
      onCloseResolver.current && onCloseResolver.current(completionStatus);
    }, []);
    return /*#__PURE__*/React.createElement(BaseCrossFlowApiProvider, {
      onOpen: onOpen
    }, children, requestOptions && /*#__PURE__*/React.createElement(ErrorBoundary, {
      onAnalyticsEvent: onAnalyticsEvent,
      onError: onError
    }, /*#__PURE__*/React.createElement(Suspense, {
      fallback: null
    }, /*#__PURE__*/React.createElement(IntegrationView, _extends({}, baseProviderProps, requestOptions, {
      onAnalyticsEvent: onAnalyticsEvent,
      originProduct: originProduct,
      onClose: onClose,
      onHandShake: onHandShake,
      plugins: plugins,
      env: env,
      redirectToWac: redirectToWac
    })))));
  };
};
export var CrossFlowProvider = createCrossFlowProvider(IntegrationView);