import _defineProperty from "@babel/runtime/helpers/defineProperty";
import { CallbackStatus, CallbackWithTimeout } from './CallbackWithTimeout';
const SCHEDULER_OPTIONS_DEFAULT = {
  minRetryDelay: 1000,
  maxRetryDelay: 30000,
  backoffFactor: 2,
  backoffJitter: 0,
  waitInterval: 500,
  callbackTimeoutPeriod: 5000
};
export let QueuedScheduleTypes;

(function (QueuedScheduleTypes) {
  QueuedScheduleTypes[QueuedScheduleTypes["NONE"] = 0] = "NONE";
  QueuedScheduleTypes[QueuedScheduleTypes["IMMEDIATE"] = 1] = "IMMEDIATE";
  QueuedScheduleTypes[QueuedScheduleTypes["WAIT"] = 2] = "WAIT";
})(QueuedScheduleTypes || (QueuedScheduleTypes = {}));

export default class Scheduler {
  constructor(retryOptions, callback) {
    _defineProperty(this, "schedule", ({
      immediate
    } = {
      immediate: false
    }) => {
      if (this.operationInFlight) {
        if (immediate) {
          this.queuedSchedule = QueuedScheduleTypes.IMMEDIATE;
        } else if (this.queuedSchedule !== QueuedScheduleTypes.IMMEDIATE) {
          this.queuedSchedule = QueuedScheduleTypes.WAIT;
        } // Only run immediately if we have no failures

      } else if (immediate && this.failureCount === 0) {
        this.clearTimeout();
        this.run(); // Backoff
      } else if (this.failureCount > 0 && this.scheduledTimeout === null) {
        this.scheduledTimeout = window.setTimeout(this.run, this.calculateBackoff()); // Schedule as normal
      } else if (this.scheduledTimeout === null) {
        this.scheduledTimeout = window.setTimeout(this.run, this.options.waitInterval);
      }
    });

    _defineProperty(this, "stop", () => {
      this.clearTimeout();
      this.queuedSchedule = QueuedScheduleTypes.NONE;
    });

    _defineProperty(this, "getFailureCount", () => this.failureCount);

    _defineProperty(this, "getCallbackStatus", () => {
      return this.callbackTimer.getCallbackStatus();
    });

    _defineProperty(this, "clearTimeout", () => {
      if (this.scheduledTimeout !== null) {
        window.clearTimeout(this.scheduledTimeout);
        this.scheduledTimeout = null;
      }
    });

    _defineProperty(this, "run", () => {
      this.operationInFlight = true;
      this.clearTimeout();

      try {
        this.callbackTimer.executeCallbackWithTimeout( // callback to execute
        this.callback, // when callback completes, call this function
        this.done, // on timeout, do this instead
        () => this.done(true));
      } catch (err) {
        this.done(err);
      }
    });

    _defineProperty(this, "done", err => {
      this.operationInFlight = false;

      if (err || this.callbackTimer.getCallbackStatus() === CallbackStatus.TIMED_OUT) {
        this.failureCount++;
        this.clearTimeout();
      } else {
        this.failureCount = 0;
      }

      this.processQueuedSchedule();
    });

    _defineProperty(this, "processQueuedSchedule", () => {
      if (this.queuedSchedule !== QueuedScheduleTypes.NONE) {
        const immediate = this.queuedSchedule === QueuedScheduleTypes.IMMEDIATE;
        this.queuedSchedule = QueuedScheduleTypes.NONE;
        this.schedule({
          immediate
        });
      } else if (this.failureCount > 0) {
        // This will schedule tasks when this._done was called with a truthy value
        // For example, when this.callback(this._done) was not called within
        // this.callbackTimeoutPeriod
        this.schedule();
      }
    });

    _defineProperty(this, "calculateBackoff", () => {
      const {
        minRetryDelay,
        maxRetryDelay,
        backoffFactor,
        backoffJitter
      } = this.options;
      let ms = minRetryDelay * backoffFactor ** this.failureCount;

      if (backoffJitter) {
        const rand = Math.random();
        const deviation = Math.floor(rand * backoffJitter * ms);

        if (Math.floor(rand * 10) < 5) {
          ms -= deviation;
        } else {
          ms += deviation;
        }
      }

      return Number(Math.min(ms, maxRetryDelay).toPrecision(1));
    });

    this.options = {
      minRetryDelay: retryOptions.minRetryDelay || SCHEDULER_OPTIONS_DEFAULT.minRetryDelay,
      maxRetryDelay: retryOptions.maxRetryDelay || SCHEDULER_OPTIONS_DEFAULT.maxRetryDelay,
      backoffFactor: retryOptions.backoffFactor || SCHEDULER_OPTIONS_DEFAULT.backoffFactor,
      backoffJitter: retryOptions.backoffJitter || SCHEDULER_OPTIONS_DEFAULT.backoffJitter,
      waitInterval: retryOptions.waitInterval || SCHEDULER_OPTIONS_DEFAULT.waitInterval,
      callbackTimeoutPeriod: retryOptions.callbackTimeoutPeriod || SCHEDULER_OPTIONS_DEFAULT.callbackTimeoutPeriod
    };
    this.scheduledTimeout = null;
    this.failureCount = 0;
    this.callback = callback;
    this.operationInFlight = false;
    this.queuedSchedule = QueuedScheduleTypes.NONE;
    this.callbackTimer = new CallbackWithTimeout(this.options.callbackTimeoutPeriod);
  }

}