import _defineProperty from "@babel/runtime/helpers/defineProperty";
export let CallbackStatus;

(function (CallbackStatus) {
  CallbackStatus["IDLE"] = "idle";
  CallbackStatus["RUNNING"] = "running";
  CallbackStatus["COMPLETED"] = "completed";
  CallbackStatus["TIMED_OUT"] = "timedOut";
})(CallbackStatus || (CallbackStatus = {}));

export let CallbackEvent;

(function (CallbackEvent) {
  CallbackEvent["EXECUTE"] = "execute";
  CallbackEvent["COMPLETE"] = "complete";
  CallbackEvent["TIMEOUT"] = "timeout";
})(CallbackEvent || (CallbackEvent = {}));

export class CallbackWithTimeout {
  // Milliseconds to wait
  // Tracks the settimeout; so that we can clear the timeout
  constructor(timeoutPeriod) {
    _defineProperty(this, "timeoutHandle", undefined);

    _defineProperty(this, "callbackStatus", CallbackStatus.IDLE);

    if (timeoutPeriod > 0) {
      this.timeoutPeriod = timeoutPeriod;
      return;
    }

    throw new Error('CallbackWithTimeout requires timeout period higher than 0');
  } // This is a state machine to control the flow of execution.
  // IDLE -> RUNNING -> COMPLETED
  // IDLE -> RUNNING -> TIMEDOUT


  transitionCallbackStatus(currentStatus, event) {
    switch (currentStatus) {
      case CallbackStatus.IDLE:
      case CallbackStatus.TIMED_OUT:
      case CallbackStatus.COMPLETED:
        if (event === CallbackEvent.EXECUTE) {
          this.callbackStatus = CallbackStatus.RUNNING;
        }

        break;

      case CallbackStatus.RUNNING:
        switch (event) {
          case CallbackEvent.COMPLETE:
            this.callbackStatus = CallbackStatus.COMPLETED;
            break;

          case CallbackEvent.TIMEOUT:
            this.callbackStatus = CallbackStatus.TIMED_OUT;
            break;
        }

        break;

      default:
        this.callbackStatus = currentStatus;
    }
  } // Start a timeout. If this.callback(this._done) does not finish
  // by this.options.callbackTimeoutPeriod time period,
  // we will call done with a true value.


  executeCallbackWithTimeout(callback, onDone, onTimeout) {
    this.transitionCallbackStatus(this.callbackStatus, CallbackEvent.EXECUTE); // Setting timeout

    this.timeoutHandle = window.setTimeout(() => {
      this.transitionCallbackStatus(this.callbackStatus, CallbackEvent.TIMEOUT);
      onTimeout();
    }, this.timeoutPeriod); // Executing callback

    callback(err => {
      this.cancelTimeout();

      if (this.getCallbackStatus() !== CallbackStatus.TIMED_OUT) {
        this.transitionCallbackStatus(this.callbackStatus, CallbackEvent.COMPLETE);
        onDone(err);
      }
    });
  }

  getCallbackStatus() {
    return this.callbackStatus;
  } // This allows us to cancel the timeout function, for example, if the callback finishes before the timeout period
  // or, if the user wants to manually cancel the timeout


  cancelTimeout() {
    if (this.timeoutPeriod > 0 && this.timeoutHandle) {
      window.clearTimeout(this.timeoutHandle);
      this.timeoutHandle = undefined;
    }
  }

}