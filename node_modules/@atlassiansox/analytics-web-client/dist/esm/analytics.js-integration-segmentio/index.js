/*
(The MIT License)

Copyright (c) 2015 Segment.io <friends@segment.com>

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
'Software'), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

/**
 * Module dependencies.
 */
const extend = require('@ndhoule/extend');

const keys = require('@ndhoule/keys');

const ads = require('@segment/ad-params');

const integration = require('@segment/analytics.js-integration');

const protocolLib = require('@segment/protocol');

const sendLib = require('@segment/send-json');

const topDomain = require('@segment/top-domain');

const utm = require('@segment/utm-params');

const clone = require('component-clone');

const cookie = require('component-cookie');

const json = require('json3');

const md5 = require('spark-md5').hash;

const uuid = require('uuid').v4;

const localstorage = require('yields-store');

const createBatchableQueue = require('../resilienceQueue').default;

const getMetricsCollector = require('../resilienceQueue/Metrics').default;

const purgeOrphans = require('./purgeOrphanedQueues').default;
/**
 * Cookie options
 */


const cookieOptions = {
  // 1 year
  maxage: 31536000000,
  secure: window.location.protocol === 'https:',
  path: '/'
};
/**
 * Segment messages can be a maximum of 32kb.
 */

const MAX_SIZE = 32 * 1000;
/**
 * Queue options
 *
 * Attempt with exponential backoff for upto 10 times.
 * Backoff periods are: 1s, 2s, 4s, 8s, 16s, 32s, 64s, 128s (~2m), 256s (~4m),
 * 512s (~8.5m) and 1024s (~17m).
 */

const defaultQueueOptions = {
  maxRetryDelay: 60000,
  // max interval of 1min. Added as a guard.
  minRetryDelay: 1000,
  // first attempt (1s)
  backoffFactor: 2,
  maxAttempts: 10,
  maxItems: 100
};
/**
 * Expose `Segment` integration.
 */

const Segment = integration('Segment.io').option('apiKey', '').option('apiScheme', 'https').option('apiHost', 'api.segment.io/v1').option('crossDomainIdServers', []).option('retryQueue', true).option('retryQueuePrefix', 'awc').option('addBundledMetadata', false).option('unbundledIntegrations', []).option('retryQueueOptions', defaultQueueOptions).option('requestTimeout', 10 * 1000); // @ts-ignore

exports = Segment; // @ts-ignore

module.exports = Segment;
/**
 * Get the store.
 *
 * @return {Function}
 */
// @ts-ignore

exports.storage = function _storage() {
  return protocolLib() === 'file:' || protocolLib() === 'chrome-extension:' ? localstorage : cookie;
};
/**
 * Expose global for testing.
 */
// @ts-ignore


exports.global = window;
/**
 * Send the given `obj` and `headers` to `url` with the specified `timeout` and
 * `fn(err, req)`. Exported for testing.
 *
 * @param {String} url
 * @param {Object} obj
 * @param {Object} headers
 * @param {long} timeout
 * @param {Function} fn
 * @api private
 */
// @ts-ignore

exports.sendJsonWithTimeout = function _sendJsonWithTimeout(url, obj, headers, timeout, fn) {
  // only proceed with our new code path when cors is supported. this is
  // unlikely to happen in production, but we're being safe to preserve backward
  // compatibility.
  if (sendLib.type !== 'xhr') {
    sendLib(url, obj, headers, fn);
    return;
  }

  const req = new XMLHttpRequest();

  function done() {
    if (req.readyState === 4) {
      // Fail on 429 and 5xx HTTP errors
      if (req.status === 429 || req.status === 0 || req.status >= 500 && req.status < 600) {
        fn(new Error(`HTTP Error ${req.status} (${req.status === 0 ? 'Network error' : req.statusText})`));
      } else {
        fn(null, req);
      }
    }
  }

  req.onerror = fn;
  req.onreadystatechange = done;
  req.withCredentials = true;
  req.open('POST', url, true);
  req.timeout = timeout;
  req.ontimeout = fn; // TODO: Remove this eslint disable
  // eslint-disable-next-line guard-for-in
  // @ts-ignore

  Object.entries(headers).forEach(([key, value]) => {
    req.setRequestHeader(key, value);
  });
  req.send(json.stringify(obj));
};

Segment.prototype.attachXid = function _attachXid(item, xidCallback) {
  if (xidCallback && xidCallback instanceof Function) {
    if (item && item.msg && item.msg.properties && ['screen', 'ui', 'operational', 'track'].indexOf(item.msg.properties.eventType) > -1) {
      const xid = xidCallback();

      if (xid && Array.isArray(xid)) {
        item.msg.properties.xid = xid;
      }
    }

    if (item && item.msg && item.msg.traits && item.msg.traits.userIdType && item.msg.type === 'identify') {
      const xid = xidCallback();

      if (xid && Array.isArray(xid)) {
        item.msg.traits.xid = xid;
      }
    }
  }

  return item;
};

Segment.prototype.attachXids = function _attachXids(items) {
  if (this._xidPromiseCallback) {
    return this._xidPromiseCallback.then(xidCallback => {
      if (Array.isArray(items)) {
        return items.map(item => this.attachXid(item, xidCallback));
      }

      return this.attachXid(items, xidCallback);
    }).catch(() => items);
  }

  return items;
};

Segment.prototype.proccessBatchItems = function _proccessBatchItems(originalItems, done) {
  // eslint-disable-next-line @typescript-eslint/no-this-alias
  const self = this;
  const metricsPayload = this.metrics.getMetricsPayload();

  const httpRetryCount = this._lsqueue.getGlobalRetryCount();

  const process = items => {
    const sentAt = new Date().toISOString();
    const batchItems = items.map(item => {
      item.msg.sentAt = sentAt;
      return item.msg;
    });
    const metadata = {};
    Object.entries(metricsPayload).forEach(([key, value]) => {
      if (value !== 0) {
        metadata[key] = value;
      }
    });

    if (httpRetryCount) {
      metadata.httpRetryCount = httpRetryCount;
    }

    const batchObj = {
      batch: batchItems,
      sentAt,
      metadata
    };
    const url = `${this.options.apiScheme}://${this.options.apiHost}/batch`;
    const headers = {
      'Content-Type': 'text/plain'
    }; // send with 10s timeout

    return Segment.sendJsonWithTimeout(url, batchObj, headers, this.options.requestTimeout, (err, res) => {
      self.debug('sent %O, received %O', batchObj, [err, res]);

      if (err) {
        return done(err);
      } else {
        this.metrics.subtractFromMetrics(metricsPayload);
        return done(null, res);
      }
    });
  };

  if (this._xidPromiseCallback) {
    return this.attachXids(originalItems).then(items => {
      process(items);
    });
  }

  return process(originalItems);
};
/**
 * Initialize.
 *
 * https://github.com/segmentio/segmentio/blob/master/modules/segmentjs/segment.js/v1/segment.js
 *
 * @api public
 */


Segment.prototype.initialize = function _initialize() {
  // eslint-disable-next-line @typescript-eslint/no-this-alias
  const self = this;

  if (this.options.retryQueue) {
    this._lsqueue = createBatchableQueue(this.options.retryQueuePrefix, this.proccessBatchItems.bind(this), this.options.product, this.options.retryQueueOptions);

    this._lsqueue.start();
  }

  if (this.options.xidPromiseGetter) {
    this._xidPromiseCallback = this.options.xidPromiseGetter();
  }

  this.metrics = getMetricsCollector();
  this.ready();
  this.analytics.on('invoke', msg => {
    const action = msg.action();
    const listener = `on${msg.action()}`;
    self.debug('%s %o', action, msg);

    if (self[listener]) {
      self[listener](msg);
    }

    self.ready();
  }); // Migrate from old cross domain id cookie names

  if (this.cookie('segment_cross_domain_id')) {
    this.cookie('seg_xid', this.cookie('segment_cross_domain_id'));
    this.cookie('seg_xid_fd', this.cookie('segment_cross_domain_id_from_domain'));
    this.cookie('seg_xid_ts', this.cookie('segment_cross_domain_id_timestamp'));
    this.cookie('segment_cross_domain_id', null);
    this.cookie('segment_cross_domain_id_from_domain', null);
    this.cookie('segment_cross_domain_id_timestamp', null);
  } // At this moment we intentionally do not want events to be queued while we retrieve the `crossDomainId`
  // so `.ready` will get called right away and we'll try to figure out `crossDomainId`
  // separately


  if (this.options.crossDomainIdServers && this.options.crossDomainIdServers.length > 0) {
    this.retrieveCrossDomainId();
  }

  purgeOrphans(this.options.retryQueuePrefix);
};
/**
 * Loaded.
 *
 * @api private
 * @return {boolean}
 */


Segment.prototype.loaded = function _loaded() {
  return true;
};
/**
 * Page.
 *
 * @api public
 * @param {Page} page
 */


Segment.prototype.onpage = function _onpage(page) {
  this.enqueue('/p', page.json());
};
/**
 * Identify.
 *
 * @api public
 * @param {Identify} identify
 */


Segment.prototype.onidentify = function _onidentity(identify) {
  this.enqueue('/i', identify.json());
};
/**
 * Group.
 *
 * @api public
 * @param {Group} group
 */


Segment.prototype.ongroup = function _ongroup(group) {
  this.enqueue('/g', group.json());
};
/**
 * ontrack.
 *
 * TODO: Document this.
 *
 * @api private
 * @param {Track} track
 */


Segment.prototype.ontrack = function _ontrack(track) {
  const trackJSON = track.json(); // TODO: figure out why we need traits.

  delete trackJSON.traits;
  this.enqueue('/t', trackJSON);
};
/**
 * Alias.
 *
 * @api public
 * @param {Alias} alias
 */


Segment.prototype.onalias = function _onalias(alias) {
  const aliasJSON = alias.json();
  const user = this.analytics.user();
  aliasJSON.previousId = aliasJSON.previousId || aliasJSON.from || user.id() || user.anonymousId();
  aliasJSON.userId = aliasJSON.userId || aliasJSON.to;
  delete aliasJSON.from;
  delete aliasJSON.to;
  this.enqueue('/a', aliasJSON);
};
/**
 * Normalize the given `msg`.
 *
 * @api private
 * @param {Object} msg
 */


Segment.prototype.normalize = function _normalize(msg) {
  this.debug('normalize %o', msg);
  const user = this.analytics.user(); // @ts-ignore

  const {
    global
  } = exports;
  const query = global.location.search;
  msg.context = msg.context || msg.options || {};
  const ctx = msg.context;
  delete msg.options;
  msg.writeKey = this.options.apiKey;
  ctx.userAgent = navigator.userAgent;

  if (!ctx.library) {
    ctx.library = {
      name: 'analytics.js',
      version: this.analytics.VERSION
    };
  }

  const crossDomainId = this.cookie('seg_xid');

  if (crossDomainId) {
    if (!ctx.traits) {
      ctx.traits = {
        crossDomainId
      };
    } else if (!ctx.traits.crossDomainId) {
      ctx.traits.crossDomainId = crossDomainId;
    }
  } // if user provides campaign via context, do not overwrite with UTM qs param


  if (query && !ctx.campaign) {
    ctx.campaign = utm(query);
  }

  this.referrerId(query, ctx);
  msg.userId = msg.userId || user.id();
  msg.anonymousId = user.anonymousId();
  msg.sentAt = new Date(); // Add _metadata.

  const failedInitializations = this.analytics.failedInitializations || [];
  /* eslint-disable no-underscore-dangle */

  if (failedInitializations.length > 0) {
    msg._metadata = {
      failedInitializations
    };
  }

  if (this.options.addBundledMetadata) {
    const bundled = keys(this.analytics.Integrations);
    msg._metadata = msg._metadata || {};
    msg._metadata.bundled = bundled;
    msg._metadata.unbundled = this.options.unbundledIntegrations;
  }
  /* eslint-enable no-underscore-dangle */
  // add some randomness to the messageId checksum


  msg.messageId = `ajs-${md5(json.stringify(msg) + uuid())}`;
  this.debug('normalized %o', msg);
  this.ampId(ctx);
  return msg;
};
/**
 * Add amp id if it exists.
 *
 * @param {Object} ctx
 */


Segment.prototype.ampId = function _ampId(ctx) {
  const ampId = this.cookie('segment_amp_id');

  if (ampId) {
    ctx.amp = {
      id: ampId
    };
  }
};
/**
 * Send `obj` to `path`.
 *
 * @api private
 * @param {string} path
 * @param {Object} obj
 * @param {Function} fn
 */


Segment.prototype.enqueue = function _enqueue(path, message, fn) {
  const url = `${this.options.apiScheme}://${this.options.apiHost}${path}`;
  const headers = {
    'Content-Type': 'text/plain'
  };
  const msg = this.normalize(message); // Print a log statement when messages exceed the maximum size. In the future,
  // we may consider dropping this event on the client entirely.

  if (json.stringify(msg).length > MAX_SIZE) {
    this.debug('message must be less than 32kb %O', msg);
  }

  this.debug('enqueueing %O', msg); // eslint-disable-next-line @typescript-eslint/no-this-alias

  const self = this;

  if (this.options.retryQueue) {
    this._lsqueue.addItem({
      url,
      headers,
      msg
    });
  } else {
    // eslint-disable-next-line consistent-return
    sendLib(url, msg, headers, (err, res) => {
      self.debug('sent %O, received %O', msg, [err, res]);

      if (fn) {
        if (err) {
          return fn(err);
        }

        fn(null, res);
      }
    });
  }
};
/**
 * Gets/sets cookies on the appropriate domain.
 *
 * @api private
 * @param {string} name
 * @param {*} val
 */
// eslint-disable-next-line consistent-return


Segment.prototype.cookie = function _cookie(name, val) {
  const store = Segment.storage();

  if (arguments.length === 1) {
    return store(name);
  } // @ts-ignore


  const {
    global
  } = exports;
  const {
    href
  } = global.location;
  let domain = `.${topDomain(href)}`;

  if (domain === '.') {
    domain = '';
  }

  this.debug('store domain %s -> %s', href, domain);
  const opts = clone(cookieOptions);
  opts.domain = domain;
  this.debug('store %s, %s, %o', name, val, opts);
  store(name, val, opts); // eslint-disable-next-line consistent-return

  if (store(name)) {
    return;
  }

  delete opts.domain;
  this.debug('fallback store %s, %s, %o', name, val, opts);
  store(name, val, opts);
};
/**
 * Add referrerId to context.
 *
 * TODO: remove.
 *
 * @api private
 * @param {Object} query
 * @param {Object} ctx
 */


Segment.prototype.referrerId = function _referrerId(query, ctx) {
  let stored = this.cookie('s:context.referrer');
  let ad;

  if (stored) {
    stored = json.parse(stored);
  }

  if (query) {
    ad = ads(query);
  }

  ad = ad || stored;

  if (!ad) {
    return;
  }

  ctx.referrer = extend(ctx.referrer || {}, ad);
  this.cookie('s:context.referrer', json.stringify(ad));
};
/**
 * getTld
 * Get domain.com from subdomain.domain.com, etc.
 * @param {string} domain
 * @return {string} tld
 */


function getTld(domain) {
  return domain.split('.').splice(-2).join('.');
}
/**
 * getJson
 * @param {string} url
 * @param {function} callback => err, json
 */


function getJson(url, callback) {
  const xhr = new XMLHttpRequest();
  xhr.open('GET', url, true);
  xhr.withCredentials = true;

  xhr.onreadystatechange = function _onreadystatechange() {
    if (xhr.readyState === XMLHttpRequest.DONE) {
      if (xhr.status >= 200 && xhr.status < 300) {
        callback(null, xhr.responseText ? json.parse(xhr.responseText) : null);
      } else {
        callback(xhr.statusText || 'Unknown Error', null);
      }
    }
  };

  xhr.send();
}
/**
 * getCrossDomainId
 * @param {Array} domain
 * @param {string} writeKey
 * @param {function} callback => err, {domain, id}
 */


function getCrossDomainIdFromSingleServer(domain, writeKey, callback) {
  const endpoint = `https://${domain}/v1/id/${writeKey}`;
  getJson(endpoint, (err, res) => {
    if (err) {
      callback(err, null);
    } else {
      callback(null, {
        domain,
        id: res && res.id || null
      });
    }
  });
}
/**
 * getCrossDomainIdFromServers
 * @param {Array} domains
 * @param {string} writeKey
 * @param {function} callback => err, {domain, id}
 */


function getCrossDomainIdFromServerList(domains, writeKey, callback) {
  // Should not happen but special case
  if (domains.length === 0) {
    callback(null, null);
  }

  let crossDomainIdFound = false;
  let finishedRequests = 0;
  let error = null;
  domains.forEach(domain => {
    getCrossDomainIdFromSingleServer(domain, writeKey, (err, res) => {
      finishedRequests++;

      if (err) {
        // if request against a particular domain fails, we won't early exit
        // but rather wait and see if requests to other domains succeed
        error = err;
      } else if (res && res.id && !crossDomainIdFound) {
        // If we found an xid from any of the servers, we'll just early exit and callback
        crossDomainIdFound = true;
        callback(null, res);
      }

      if (finishedRequests === domains.length && !crossDomainIdFound) {
        // Error is non-null if we encountered an issue, otherwise error will be null
        // meaning that no domains in the list has an xid for current user
        callback(error, null);
      }
    });
  });
}
/**
 * retrieveCrossDomainId.
 *
 * @api private
 * @param {function) callback => err, {crossDomainId, fromServer, timestamp}
 */


Segment.prototype.retrieveCrossDomainId = function _retrieveCrossDomainId(callback) {
  if (!this.options.crossDomainIdServers) {
    if (callback) {
      callback('crossDomainId not enabled', null);
    }

    return;
  }

  if (!this.cookie('seg_xid')) {
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    const self = this;
    const writeKey = this.options.apiKey; // Exclude the current domain from the list of servers we're querying

    const currentTld = getTld(window.location.hostname);
    const domains = [];
    this.options.crossDomainIdServers.forEach(domain => {
      if (getTld(domain) !== currentTld) {
        domains.push(domain);
      }
    });
    getCrossDomainIdFromServerList(domains, writeKey, (err, res) => {
      if (err) {
        // We optimize for no conflicting xid as much as possible. So bail out if there is an
        // error and we cannot be sure that xid does not exist on any other domains
        if (callback) {
          callback(err, null);
        }

        return;
      }

      let crossDomainId = null;
      let fromDomain = null;

      if (res) {
        crossDomainId = res.id;
        fromDomain = res.domain;
      } else {
        crossDomainId = uuid();
        fromDomain = window.location.hostname;
      }

      const currentTimeMillis = new Date().getTime();
      self.cookie('seg_xid', crossDomainId); // Not actively used. Saving for future conflict resolution purposes

      self.cookie('seg_xid_fd', fromDomain);
      self.cookie('seg_xid_ts', currentTimeMillis);
      self.analytics.identify({
        crossDomainId
      });

      if (callback) {
        callback(null, {
          crossDomainId,
          fromDomain,
          timestamp: currentTimeMillis
        });
      }
    });
  }
};