import _defineProperty from "@babel/runtime/helpers/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import DuplicateEventDetector from '../analytics.js-integration-segmentio/DuplicateEventDetector';
import Scheduler from '../analytics.js-integration-segmentio/Scheduler';
import getMetricsCollector from './Metrics';
import { ResilienceMechanism } from './types';

const Queue = require('@segment/localstorage-retry');

const DEFAULT_FLUSH_BATCH_SIZE = 7; // These must all be 1. If they are 0, they will not be truthy and in built defaults will be used.

const QUEUE_RETRY_OPTION_OVERRIDES = {
  minRetryDelay: 1,
  maxRetryDelay: 1,
  backoffFactor: 1,
  backoffJitter: 0
};
/**
 * Create a queue, backed by localstorage, in which items are processed by the queue in batches
 *
 * @param {Object} options queue options,
 * @param {Function} batchProcessFunc the function to process a batch of items from the queue
 */

export default class PushBatchableQueue {
  constructor(retryQueuePrefix, retryQueueOptions, batchProcessFunc) {
    _defineProperty(this, "start", () => {
      this.queue.start();
    });

    _defineProperty(this, "getGlobalRetryCount", () => this.scheduler.getFailureCount());

    _defineProperty(this, "_flush", done => {
      if (this.currentBatch.length !== 0) {
        const batchedQueuedObjects = this.currentBatch.splice(0, this.flushBatchSize);
        const batchedItems = batchedQueuedObjects.map(queuedItem => queuedItem.item);
        batchedItems.forEach(item => {
          /* eslint-disable no-underscore-dangle */
          if (item.msg && item.msg._metadata && item.msg.messageId && this.messageFailedAttemptCounter[item.msg.messageId]) {
            item.msg._metadata.failedAttempts = this.messageFailedAttemptCounter[item.msg.messageId];
          }
          /* eslint-enable no-underscore-dangle */

        });
        const messageIds = batchedItems.map(item => item.msg.messageId);
        this.batchProcessFunc(batchedItems, (error, response) => {
          // Important to remove the events from the detector before calling done,
          // otherwise we could accidentally mark it as duplicated
          this.duplicateEventDetector.done(error, batchedItems);
          batchedQueuedObjects.forEach(item => item.done(error, response));
          done(error);

          if (!error) {
            this._resetMessageIdCounters(messageIds);
          } else {
            this._incrementMessageIdCounters(messageIds);
          }

          if (this.currentBatch.length > 0) {
            this._schedule();
          }
        });
      } else {
        done();
      }
    });

    _defineProperty(this, "_incrementMessageIdCounters", messageIds => {
      messageIds.forEach(id => {
        if (this.messageFailedAttemptCounter[id]) {
          this.messageFailedAttemptCounter[id] += 1;
        } else {
          this.messageFailedAttemptCounter[id] = 1;
        }
      });
    });

    _defineProperty(this, "_resetMessageIdCounters", messageIds => {
      messageIds.forEach(id => delete this.messageFailedAttemptCounter[id]);
    });

    _defineProperty(this, "_onDiscardedEvent", item => {
      this.metrics.addToItemsDiscardedByRetryCounter();
      delete this.messageFailedAttemptCounter[item.msg.messageId];
    });

    _defineProperty(this, "_onOverflowEvent", item => {
      this.metrics.addToItemsDiscardedByOverflowCounter();
      delete this.messageFailedAttemptCounter[item.msg.messageId];
    });

    _defineProperty(this, "_onLocalstorageDuplicateEvent", item => {
      this.metrics.addToLocalstorageDuplicateCount();
      delete this.messageFailedAttemptCounter[item.msg.messageId];
    });

    _defineProperty(this, "_schedule", () => {
      this.scheduler.schedule({
        immediate: this.currentBatch.length >= this.flushBatchSize
      });
    });

    _defineProperty(this, "_processSingleElement", (item, done) => {
      if (this.duplicateEventDetector.hasEventBeenSeen(item)) {
        done();
        this.metrics.addToDuplicateEventCounter();
        return;
      }

      this.duplicateEventDetector.addItem(item);
      this.currentBatch.push({
        item,
        done
      });

      if (this.currentBatch.length > this.maxQueueSize) {
        this.currentBatch.splice(0, this.currentBatch.length - this.maxQueueSize);
      }

      this._schedule();
    });

    _defineProperty(this, "addItem", item => {
      this.queue.addItem(item);
      this.metrics.addToEventCount();
    });

    _defineProperty(this, "stop", () => {
      this.scheduler.stop();
      this.queue.stop();
    });

    _defineProperty(this, "on", (eventName, callback) => this.queue.on(eventName, callback));

    this.maxQueueSize = retryQueueOptions.maxItems || 500;
    this.queue = new Queue(retryQueuePrefix, _objectSpread(_objectSpread({}, retryQueueOptions), QUEUE_RETRY_OPTION_OVERRIDES), this._processSingleElement);
    this.flushBatchSize = retryQueueOptions.batchFlushSize || DEFAULT_FLUSH_BATCH_SIZE;
    this.batchProcessFunc = batchProcessFunc;
    this.duplicateEventDetector = new DuplicateEventDetector();
    this.currentBatch = [];
    this.scheduler = new Scheduler(_objectSpread(_objectSpread({}, retryQueueOptions), {}, {
      waitInterval: retryQueueOptions.flushWaitMs
    }), this._flush);

    if (retryQueueOptions.flushBeforeUnload) {
      window.addEventListener("beforeunload", () => {
        this.scheduler.schedule({
          immediate: true
        });
      });
    }

    this.metrics = getMetricsCollector();
    this.metrics.setResilienceMechanism(ResilienceMechanism.LOCALSTORAGE);
    this.queue.on('discard', this._onDiscardedEvent);
    this.queue.on('overflow', this._onOverflowEvent);
    this.queue.on('duplication', this._onLocalstorageDuplicateEvent);
    this.messageFailedAttemptCounter = {};
  }

}