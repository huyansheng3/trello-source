import { CallbackProcessingErrorName } from './CallbackProcessingError';
import { MAX_MEMORY_EVENTS } from './defaults';
import IndexedDbConnector from './IndexedDbConnector';
import MemoryDb from './MemoryDb';
export default class DbDelegator {
  constructor(product, options = {}) {
    if (!product || product.length === 0 || typeof product !== 'string') {
      throw new Error('Invalid product provided');
    }

    this.product = product;

    if (options.useMemory) {
      this.resilience = new MemoryDb(product, options);
    } else {
      try {
        this.resilience = new IndexedDbConnector(product, options);
      } catch (error) {
        this.resilience = new MemoryDb(product, options);
      }
    }
  }

  addItem(item, options) {
    return this.runOrFailOver(() => this.resilience.addItem(item, options));
  }

  getItems(count) {
    return this.runOrFailOver(() => this.resilience.getItems(count));
  }

  deleteItems(itemIds) {
    return this.runOrFailOver(() => this.resilience.deleteItems(itemIds));
  }

  getItemCount() {
    return this.runOrFailOver(() => this.resilience.getItemCount());
  }

  processItems(processFn, count) {
    return this.runOrFailOver(() => this.resilience.processItems(processFn, count));
  }

  storeType() {
    return this.resilience.storeType();
  }

  async runOrFailOver(runnable) {
    try {
      return await runnable();
    } catch (error) {
      if ((error === null || error === void 0 ? void 0 : error.name) === CallbackProcessingErrorName) {
        throw error;
      } else {
        await this.failOver();
        return runnable();
      }
    }
  }

  async failOver() {
    // Attempt to get any events we can and put them into memory
    const memoryDb = new MemoryDb(this.product);

    try {
      await this.resilience.processItems(items => memoryDb.massAddItems(items), MAX_MEMORY_EVENTS);
    } catch (error) {// Dont need to catch. We are just getting events if we can
    }

    this.resilience = memoryDb;
  }

}