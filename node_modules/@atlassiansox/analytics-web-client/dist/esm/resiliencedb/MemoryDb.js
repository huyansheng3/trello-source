import _defineProperty from "@babel/runtime/helpers/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import { v4 as uuid } from 'uuid';
import CallbackProcessingError from './CallbackProcessingError';
import { MEMORY_DB_GUARD_POLICY, StoreType } from './constants';
import { GET_ITEM_COUNT, VISIBILITY_TIMEOUT } from './defaults';
import MemoryDbEventCountGuard from './MemoryDbEventCountGuard';
import { createOptionsWithDefaults } from './util';
export default class MemoryDb {
  constructor(product, options = {}) {
    this.memoryStore = [];
    this.options = createOptionsWithDefaults(options, this.storeType());

    if (!product || product.length === 0 || typeof product !== 'string') {
      throw new Error('Invalid product provided');
    }

    this.product = product;
    /**
     * This class will enforce the number of analytics events we can store in our MemoryDb
     */

    this.globalEventLimitGuard = new MemoryDbEventCountGuard(this.options.maxEventLimit, this.memoryStore);
  }
  /**
   * This method is used mainly to write new events to MemoryDB and uses the MEMORY_DB_GUARD_POLICY.EVICT_OLDEST_IF_LIMIT_EXECEEDED policy
   * to removes oldest events when limit is reached.
   */


  addItem(item, {
    id,
    retryAttempts,
    timeToProcessOffset
  } = {}) {
    const storedValue = {
      item,
      id: id || uuid(),
      retryAttempts: retryAttempts || 0,
      timeToBeProcessedAfter: Date.now() + (timeToProcessOffset || 0),
      timeAdded: Date.now(),
      product: this.product
    }; // Delegated responsiblity to event limit guard to insert to memory stored

    this.globalEventLimitGuard.insertItemsToMemoryStore([storedValue], MEMORY_DB_GUARD_POLICY.EVICT_OLDEST_IF_LIMIT_EXECEEDED);
    return Promise.resolve(storedValue.id);
  }
  /**
   * This method is used mainly to write old events to MemoryDB; moving events from LocalStorage to Memory.
   *
   * This method uses the MEMORY_DB_GUARD_POLICY.EVICT_OLDEST_IF_LIMIT_EXECEEDED policy
   * to stop exceeding the event count limit.
   *
   * This does not mean we throw away the events in LocalStorage, they will still be there, but we wont take them just yet.
   */


  massAddItems(items) {
    // Delegated responsiblity to event limit guard to insert to memory stored
    this.globalEventLimitGuard.insertItemsToMemoryStore(items, MEMORY_DB_GUARD_POLICY.ABANDON_IF_LIMIT_WILL_EXECEED);
    return Promise.resolve();
  }

  getItems(count = GET_ITEM_COUNT) {
    return Promise.resolve(this.synchronousGetItems(count));
  }

  synchronousGetItems(count = GET_ITEM_COUNT) {
    const fixedCount = count > 0 ? count : GET_ITEM_COUNT;
    const now = Date.now();
    const wrappedItems = [];

    for (let wrappedItem of this.memoryStore) {
      if (wrappedItem.timeToBeProcessedAfter <= now) {
        wrappedItems.push(_objectSpread({}, wrappedItem)); // Mutates the item in the memoryStore array, but not whats inside of wrappedItems

        wrappedItem.timeToBeProcessedAfter += VISIBILITY_TIMEOUT;
        wrappedItem.retryAttempts += 1;
      }

      if (wrappedItems.length >= fixedCount) {
        break;
      }
    }

    return wrappedItems;
  }

  deleteItems(itemIds) {
    this.memoryStore = this.memoryStore.filter(item => !itemIds.includes(item.id));
    return Promise.resolve(void 0);
  }

  getItemCount() {
    const now = Date.now();
    const count = this.memoryStore.filter(item => item.timeToBeProcessedAfter <= now).length;
    return Promise.resolve(count);
  }

  async processItems(processFn, count) {
    const items = this.synchronousGetItems(count);
    const itemIds = items.map(i => i.id);

    try {
      await processFn(items);
      return this.deleteItems(itemIds);
    } catch (error) {
      throw new CallbackProcessingError(error);
    }
  }

  storeType() {
    return StoreType.MEMORY;
  }

}