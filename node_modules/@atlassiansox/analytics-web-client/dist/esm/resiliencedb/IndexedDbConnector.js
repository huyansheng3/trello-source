import _defineProperty from "@babel/runtime/helpers/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import { v4 as uuid } from 'uuid';
import CallbackProcessingError from './CallbackProcessingError';
import { RESILIENCE_DB_NAME, RESILIENCE_STORE_NAME, RETRY_INDEX, StoreType, TIME_ADDED_INDEX, TIME_TO_PROCESS_AFTER_INDEX } from './constants';
import { GET_ITEM_COUNT, VISIBILITY_TIMEOUT } from './defaults';
import IndexedDbEventCountGuard from './IndexedDbEventCountGuard';
import { createOptionsWithDefaults } from './util';
/**
 * We have rolled our own client for IndexedDb as many Indexeddb libraries are
 * not flexible enough for our use case of:
 * 1. Adding specific indexes for time,
 * 2. Getting items on a specific index,
 * 3. Updating a field on an event while getting the event inside of a single ACID compliant transaction.
 */

export default class IndexedDbConnector {
  constructor(product, options = {}) {
    _defineProperty(this, "startDB", async () => {
      /*
      * The database version number can never change.
      * An upgrade transaction is limited to only one connection to the database.
      * Once this is done, we cannot open any connections with older versions of the schema.
      * https://www.w3.org/TR/IndexedDB/#upgrade-transaction-construct
      *
      * Due to the nature of how AWC is used (multiple tabs that are very long lived),
      * we will not be able to run version upgrades via indexeddb.
      *
      * This does not mean we cant change what is stored in the tables,
      * this limitation just prevents us from:
      *   - Creating new ObjectStores in this database connection, and
      *   - Creating new indexes on our ObjectStores
      *
      * Any upgrades we wish to run in the future will have to create a new database,
      * and migrate all the data from older databases.
      *
      * This also means any migrations we make will have to be supported until we have evidence
      * that no events are coming from old versions of the database.
      * This may take a long time.
      */
      const request = window.indexedDB.open(RESILIENCE_DB_NAME, 1);

      request.onupgradeneeded = event => {
        if (event.oldVersion !== 0) {
          throw new Error('We cannot upgarde the database. Do not do this.');
        }

        const db = request.result;
        const store = db.createObjectStore(RESILIENCE_STORE_NAME, {
          keyPath: 'id'
        });
        store.createIndex(TIME_TO_PROCESS_AFTER_INDEX, TIME_TO_PROCESS_AFTER_INDEX, {
          unique: false
        });
        store.createIndex(RETRY_INDEX, RETRY_INDEX, {
          unique: false
        });
        store.createIndex(TIME_ADDED_INDEX, TIME_ADDED_INDEX, {
          unique: false
        });
      };

      try {
        await this.requestToPromise(request);
        return request.result;
      } catch (error) {
        this.logger.error('IndexedDB failed to initialise.', error);
        throw new Error(`IndexedDB failed to initialise: ${error.message}`);
      }
    });

    _defineProperty(this, "addItem", async (item, {
      retryAttempts,
      timeToProcessOffset,
      id
    } = {}) => {
      const value = {
        item,
        retryAttempts: retryAttempts || 0,
        timeToBeProcessedAfter: Date.now() + (timeToProcessOffset || 0),
        id: id || uuid(),
        timeAdded: Date.now(),
        product: this.product
      };
      const {
        logger
      } = this;
      const {
        transaction,
        objectStore
      } = await this.getObjectStoreAndTransaction('readwrite');

      try {
        // Making space for 1 event, if required.
        await this.globalEventLimitGuard.makeSpaceForNEvents(objectStore, 1);
        const request = objectStore.add(value);
        await this.requestToPromise(request);
      } catch (error) {
        logger.log('Failed to add item to table', error);
        throw new Error('Request to add item to table failed');
      }

      await this.commitTransaction(transaction);
      return value.id;
    });

    _defineProperty(this, "getItems", async (count = GET_ITEM_COUNT) => {
      const fixedCount = count > 0 ? count : GET_ITEM_COUNT;
      const {
        logger,
        monitorErrorsOnRequest
      } = this;
      const {
        transaction,
        objectStore
      } = await this.getObjectStoreAndTransaction('readwrite');
      const timeIndex = objectStore.index(TIME_TO_PROCESS_AFTER_INDEX);
      const upperBoundOpenKeyRange = IDBKeyRange.upperBound(Date.now());
      const request = timeIndex.openCursor(upperBoundOpenKeyRange);
      const returnableItems = await new Promise(async (resolve, reject) => {
        [];
        const items = [];

        request.onerror = error => {
          logger.error('Failed to open cursor:', error);
          reject('Failed to open cursor');
        }; // Requests for Cursors call onsuccess multiple times and cannot be converted to promises


        request.onsuccess = event => {
          const cursor = event.target.result;

          if (cursor) {
            // Prevent mutation of the value we are returning
            const value = _objectSpread({}, cursor.value);

            items.push(value); // Mutations seem to be required for testing indexeddb library

            const updatedValue = cursor.value;
            updatedValue.retryAttempts += 1;
            updatedValue.timeToBeProcessedAfter = Date.now() + VISIBILITY_TIMEOUT;
            const request = cursor.update(updatedValue);
            monitorErrorsOnRequest.bind(this)(request);

            if (items.length < fixedCount) {
              cursor.continue();
            } else {
              resolve(items);
            }
          } else {
            resolve(items);
          }
        };
      });
      await this.commitTransaction(transaction);
      return returnableItems;
    });

    _defineProperty(this, "deleteItems", async itemIds => {
      const {
        transaction,
        objectStore
      } = await this.getObjectStoreAndTransaction('readwrite');

      try {
        const deletePromises = itemIds.map(id => this.deleteItem(objectStore, id));
        await this.commitTransaction(transaction);
        await Promise.all(deletePromises);
      } catch (error) {
        this.logger.warn('Failed to delete items from indexeddb.', error);
        throw error;
      }
    });

    _defineProperty(this, "getItemCount", async () => {
      const {
        transaction,
        objectStore
      } = await this.getObjectStoreAndTransaction('readonly');
      const timeIndex = objectStore.index(TIME_TO_PROCESS_AFTER_INDEX);
      const upperBoundOpenKeyRange = IDBKeyRange.upperBound(Date.now());
      const request = timeIndex.count(upperBoundOpenKeyRange);
      const event = await this.requestToPromise(request);
      await this.commitTransaction(transaction);
      return event.target.result;
    });

    _defineProperty(this, "processItems", async (processFn, count = GET_ITEM_COUNT) => {
      const items = await this.getItems(count);

      try {
        await processFn(items);
        const itemIds = items.map(item => item.id); // We should not await this delete as a rejected promise would get caught by the catch statement

        return this.deleteItems(itemIds);
      } catch (error) {
        // Eventually we will need a intermediate class to catch all errors but we should ignore this error
        // This allows libraries beneath to distinguish between a success or failure in processing to update schedulers or anything else
        // To provide back off or any other mechanism to allow what ever is cauing the errors to recover
        throw new CallbackProcessingError(error);
      }
    });

    _defineProperty(this, "deleteItem", async (objectStore, id) => {
      const {
        logger
      } = this;

      try {
        await this.requestToPromise(objectStore.delete(id));
      } catch (error) {
        logger.error('Failed to delete item:', id, error);
        throw error;
      }
    });

    _defineProperty(this, "requestToPromise", request => {
      return new Promise((resolve, reject) => {
        request.onsuccess = event => {
          resolve(event);
        };

        request.onerror = event => {
          reject(event);
        };
      });
    });

    _defineProperty(this, "monitorErrorsOnRequest", request => {
      const {
        logger
      } = this;

      request.onerror = event => {
        logger.warn('Error thrown from request:', event);
      };
    });

    _defineProperty(this, "transactionToPromise", transaction => {
      return new Promise((resolve, reject) => {
        // We will have to see how much cost there is to waiting for the transaction to complete in the real world.
        // In theory in some cases we could return as soon as the request is complete and
        // just monitor errors on transactions with the logger.
        // This maybe more of an issue in Safari and other older browsers where commit isnt available
        // and we would have to wait for the transaction to complete itself.
        transaction.oncomplete = () => {
          resolve();
        };

        transaction.onerror = event => {
          reject(event);
        };

        transaction.onabort = event => {
          reject(event);
        };
      });
    });

    _defineProperty(this, "commitTransaction", transaction => {
      try {
        if (typeof transaction.commit === 'function') {
          transaction.commit();
        }
      } catch (error) {
        this.logger.debug('Failed to force commit transaction:', error);
      }

      return this.transactionToPromise(transaction);
    });

    _defineProperty(this, "getObjectStoreAndTransaction", async mode => {
      const transaction = (await this.db).transaction(RESILIENCE_STORE_NAME, mode);
      const objectStore = transaction.objectStore(RESILIENCE_STORE_NAME);
      return {
        transaction,
        objectStore
      };
    });

    this.options = createOptionsWithDefaults(options, this.storeType());
    this.product = product;
    this.logger = this.options.logger;

    if (!window.indexedDB) {
      this.logger.warn('Browser doesn\'t support a IndexedDB.');
      throw new Error('IndexedDB not supported');
    }

    this.db = this.startDB();
    /**
     *
     * This class will enforce the number of analytics events we can store in our IndexedDB object store
     * if asked before adding items to the object store.
     */

    this.globalEventLimitGuard = new IndexedDbEventCountGuard(this.options.maxEventLimit, this.logger, this.requestToPromise, this.deleteItem);
  }

  storeType() {
    return StoreType.INDEXEDDB;
  }

}