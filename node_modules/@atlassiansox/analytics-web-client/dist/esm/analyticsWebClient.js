import _defineProperty from "@babel/runtime/helpers/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import PPromise from 'promise-polyfill';
import { XID } from '@atlassian/atl-cross-domain-tracking/dist/esm';
import { envType, eventType, isType, objectValues, originType, platformType, tenantType } from './analyticsWebTypes';
import ApdexEvent from './apdexEvent';
import BeforeSendIntegration from './beforeSendIntegration';
import createGetter from './createGetter';
import { buildActionEvent, buildActionName, buildContext, buildScreenEvent } from './eventBuilder';
import EventDelayQueue from './eventDelayQueue';
import { validateContainers, validateIdentifyEvent, validateOperationalEvent, validatePlatform, validateScreenEvent, validateTrackEvent, validateUIEvent } from './eventValidation';
import OriginTracing from './originTracing';
import PageVisibility from './pageVisibility';
import { ResilienceMechanism } from './resilienceQueue';
import SessionTracking from './sessionTracking';
import SafeSessionStorage from './storage/SafeSessionStorage';
import TabTracking from './tabTracking';
import TaskSessionStore from './taskSessionStore';
import TestingCache from './testingCache';
import UIViewedEvent from './uiViewedEvent';
import { defaultHistoryReplaceFn } from './urlUtils';
import wrapCallback from './wrapCallback';

const Analytics = require('@segment/analytics.js-core/lib/analytics');

const SegmentIO = require('./analytics.js-integration-segmentio');

const PROD_HOST = 'as.atlassian.com/api/v1';
const STARGATE_PROD_HOST = 'api-private.atlassian.com/gasv3/api/v1';
const STAGING_HOST = 'as.staging.atl-paas.net/api/v1';
const STARGATE_STAGING_HOST = 'api-private.stg.atlassian.com/gasv3/api/v1';
const STARGATE_PROXY_PATH = '/gateway/api/gasv3/api/v1';
const LAST_SCREEN_EVENT_STORAGE_KEY = 'last.screen.event';
const XID_TIMEOUT = 5000;
const MAX_DELAY_TIMEOUT = 10000;
export default class AnalyticsWebClient {
  constructor(productInfo, settings = {}) {
    _defineProperty(this, "_useStargate", useStargate => {
      if (useStargate == null) {
        return true;
      }

      return useStargate;
    });

    _defineProperty(this, "_selectHost", ({
      useStargate,
      env,
      useLegacyUrl
    }) => {
      if (!useStargate) {
        return env === envType.PROD ? PROD_HOST : STAGING_HOST;
      }

      if (useLegacyUrl) {
        return env === envType.PROD ? STARGATE_PROD_HOST : STARGATE_STAGING_HOST;
      }
      /**
       * Stargate proxy path now needs to be the default to work around browser restrictions with cookies.
       * For more details, see:
       *  - https://experimentation-platform.atlassian.net/browse/MHD-326, and
       *  - https://hello.atlassian.net/wiki/spaces/I/pages/1217206437/api-private+is+broken+is+your+product+impacted
      */


      return window.location.host + STARGATE_PROXY_PATH;
    });

    _defineProperty(this, "_endsWith", (str, suffix) => str.indexOf(suffix, str.length - suffix.length) !== -1);

    _defineProperty(this, "_changeInternalUserId", (userId, anonymousId) => {
      // Segment library workaround to change userId without triggering an identify call.
      if (this._analytics.user().id() !== userId) {
        this._analytics.user().id(userId);
      }

      if (anonymousId) {
        this._analytics.user().anonymousId(anonymousId);
      }
    });

    _defineProperty(this, "_createSubproductGetter", subproduct => createGetter(subproduct, 'Cannot get subproduct from the callback. Proceeding without it.'));

    _defineProperty(this, "_createEmbeddedProductGetter", embeddedProduct => createGetter(embeddedProduct, 'Cannot get embeddedProduct from the callback. Proceeding without it.'));

    _defineProperty(this, "_getLastScreenEvent", () => {
      try {
        return JSON.parse(this._safeSessionStorage.getItem(LAST_SCREEN_EVENT_STORAGE_KEY));
      } catch (err) {
        this._safeSessionStorage.removeItem(LAST_SCREEN_EVENT_STORAGE_KEY);

        return null;
      }
    });

    _defineProperty(this, "_setLastScreenEvent", event => {
      this._safeSessionStorage.setItem(LAST_SCREEN_EVENT_STORAGE_KEY, JSON.stringify({
        name: event.name,
        attributes: event.attributes
      }));
    });

    _defineProperty(this, "_shouldEventBeDelayed", event => {
      // TODO: this is a temporary restriction for the purposes of the Track All Changes project
      // The delay mechanism has a chance of event loss, which we can only accept for our own data at this point.
      // Once the delay queue implementation has been improved and measured to confirm that it is reliable enough,
      // then we will be able to open it up for other products to use by removing this check.
      if (!event.tags || event.tags.indexOf('measurement') === -1) {
        return false;
      }

      const isEventHighPriority = event.highPriority !== false; // defaults to true if excluded

      return this._isDelayingLowPriorityEvents && !isEventHighPriority;
    });

    _defineProperty(this, "_fireEvent", (identifier, builtEvent, context, callback) => {
      switch (builtEvent.eventType) {
        case eventType.UI:
        case eventType.OPERATIONAL:
        case eventType.TRACK:
          return this._analytics.track(identifier, builtEvent, context, callback);

        case eventType.SCREEN:
          return this._analytics.page(identifier, builtEvent, context, callback);

        case eventType.IDENTIFY:
          return this._analytics.identify(identifier, builtEvent, context, callback);

        default:
          throw new Error(`No handler has been defined for events of type ${builtEvent.eventType}`);
      }
    });

    _defineProperty(this, "_fireDelayedEvent", (identifier, builtEvent, context, userInfo) => {
      try {
        // User information can change while the delay period is active, so we need to restore the values that
        // were active when the event was originally fired.
        this._changeInternalUserId(userInfo.userId, userInfo.anonymousId);

        builtEvent.tags = [...(builtEvent.tags || []), 'sentWithDelay']; // The callbacks for delayed events are fired immediately, so there is nothing to pass through for this argument.

        this._fireEvent(identifier, builtEvent, context, undefined);
      } finally {
        this._changeInternalUserId(this._userInfo.userId, this._userInfo.anonymousId);
      }
    });

    _defineProperty(this, "_delayEvent", (identifier, builtEvent, context, userInfo, callback) => {
      this._delayQueue.push(identifier, builtEvent, context, userInfo); // Fire the callback immediately, as we can consider the event successfully processed at this point


      if (callback) {
        callback();
      }
    });

    _defineProperty(this, "_processEvent", (identifier, builtEvent, context, callback) => {
      this._testingCache.saveEvent(builtEvent);

      if (this._shouldEventBeDelayed(builtEvent)) {
        this._delayEvent(identifier, builtEvent, context, this._userInfo, callback);
      } else {
        this._fireEvent(identifier, builtEvent, context, callback);
      }
    });

    _defineProperty(this, "setEmbeddedProduct", embeddedProduct => {
      this._productInfo.embeddedProduct = this._createEmbeddedProductGetter(embeddedProduct);
      this.resetUIViewedTimers();
    });

    _defineProperty(this, "clearEmbeddedProduct", () => {
      this._productInfo.embeddedProduct = this._createEmbeddedProductGetter(null);
    });

    _defineProperty(this, "setSubproduct", subproduct => {
      this._productInfo.subproduct = this._createSubproductGetter(subproduct);
      this.resetUIViewedTimers();
    });

    _defineProperty(this, "setOriginTracingHandlers", originParamHandlerMapping => {
      const capturedOriginTraces = this.originTracing.handleOriginParameters(originParamHandlerMapping, this._historyReplaceFn);
      Object.keys(capturedOriginTraces).forEach(x => {
        if (typeof capturedOriginTraces[x].taskSessionId !== 'undefined') {
          this.task.createTaskSessionWithProvidedId(x, capturedOriginTraces[x].taskSessionId);
        }
      });
      const originAttributes = {};
      Object.keys(capturedOriginTraces).forEach(x => {
        if (capturedOriginTraces[x].originTracingAttributes) {
          originAttributes[x] = capturedOriginTraces[x].originTracingAttributes;
        } else {
          // eslint-disable-next-line no-console
          console.warn(`Handling method for origin parameter ${x} has not returned any attributes`);
        }
      });

      if (Object.keys(capturedOriginTraces).length > 0) {
        this.sendOperationalEvent({
          action: 'landed',
          actionSubject: 'origin',
          source: 'webClient',
          attributes: {
            originTracesLanded: originAttributes
          }
        }, // eslint-disable-next-line @typescript-eslint/no-empty-function
        () => {});
      }
    });

    _defineProperty(this, "setTenantInfo", (tenantIdType, tenantId) => {
      if (!tenantIdType) {
        throw new Error('Missing tenantIdType');
      }

      if (tenantIdType !== tenantType.NONE && !tenantId) {
        throw new Error('Missing tenantId');
      }

      if (!isType(tenantType, tenantIdType)) {
        throw new Error(`Invalid tenantIdType '${tenantIdType}', ` + `must be an tenantType: [${objectValues(tenantType)}]`);
      }

      this._tenantInfo = {
        tenantIdType,
        tenantId
      };
    });

    _defineProperty(this, "clearTenantInfo", () => {
      this._tenantInfo = {};
    });

    _defineProperty(this, "setOrgInfo", orgId => {
      if (!orgId) {
        throw new Error('Missing orgId');
      }

      this._orgInfo = {
        orgId
      };
    });

    _defineProperty(this, "clearOrgInfo", () => {
      this._orgInfo = {};
    });

    _defineProperty(this, "setUserInfo", (userIdType, userId) => {
      validateIdentifyEvent(userIdType, userId);

      this._changeInternalUserId(userId);

      this._userInfo = {
        userIdType,
        userId,
        anonymousId: this._analytics.user().anonymousId()
      };
    });

    _defineProperty(this, "clearUserInfo", () => {
      this._changeInternalUserId(null);

      this._userInfo = {
        anonymousId: this._analytics.user().anonymousId()
      };
    });

    _defineProperty(this, "setUIViewedAttributes", uiViewedAttributes => {
      if (!uiViewedAttributes) {
        throw new Error('Missing uiViewedAttributes');
      }

      if (typeof uiViewedAttributes !== 'object' || Array.isArray(uiViewedAttributes)) {
        throw new Error('Invalid uiViewedAttributes type, should be a non array object');
      }

      this._uiViewedAttributes = _objectSpread({}, uiViewedAttributes);
    });

    _defineProperty(this, "clearUIViewedAttributes", () => {
      this._uiViewedAttributes = {};
    });

    _defineProperty(this, "sendIdentifyEvent", (userIdType, userId, callback) => {
      this.setUserInfo(userIdType, userId);
      const builtEvent = {
        userIdType,
        eventType: eventType.IDENTIFY
      };

      this._processEvent(userId, builtEvent, this._context, callback);
    });

    _defineProperty(this, "sendPageEvent", (name, callback) => {
      this.sendScreenEvent(name, callback);
    });

    _defineProperty(this, "sendScreenEvent", (event, callback, attributes) => {
      let screenName;
      let screenAttributes;
      let screenContainers;
      let screenTags;

      if (typeof event === 'object') {
        /* This is for retrocompatibility */
        screenName = event.name;
        screenAttributes = event.attributes;
        screenContainers = event.containers;
        screenTags = event.tags;
      } else {
        screenName = event;
        screenAttributes = attributes;
      }

      validateScreenEvent(screenName);
      validateContainers(screenContainers);
      const builtEvent = buildScreenEvent(this._productInfo, this._tenantInfo, this._userInfo, screenAttributes, // TODO: Remove the as any and move into a place where we know event is an object
      event.nonPrivacySafeAttributes, screenTags, this._tabTracking.getCurrentTabId(), this._sessionTracking.getCurrentSessionId(), this.task.getAllTaskSessions(), this._orgInfo, screenContainers);

      const builtEventWithName = _objectSpread({
        name: screenName
      }, builtEvent);

      this._setLastScreenEvent(builtEventWithName);

      this._processEvent(screenName, builtEvent, this._context, wrapCallback(callback, builtEventWithName));
    });

    _defineProperty(this, "sendTrackEvent", (event, callback) => {
      validateTrackEvent(event);
      const builtEvent = buildActionEvent(this._productInfo, this._tenantInfo, this._userInfo, event, eventType.TRACK, this._tabTracking.getCurrentTabId(), this._sessionTracking.getCurrentSessionId(), this.task.getAllTaskSessions(), this._orgInfo);

      this._processEvent(buildActionName(event), builtEvent, this._context, wrapCallback(callback, builtEvent));
    });

    _defineProperty(this, "sendUIEvent", (event, callback) => {
      validateUIEvent(event);
      const builtEvent = buildActionEvent(this._productInfo, this._tenantInfo, this._userInfo, event, eventType.UI, this._tabTracking.getCurrentTabId(), this._sessionTracking.getCurrentSessionId(), this.task.getAllTaskSessions(), this._orgInfo);

      this._processEvent(buildActionName(event), builtEvent, this._context, wrapCallback(callback, builtEvent));
    });

    _defineProperty(this, "sendOperationalEvent", (event, callback) => {
      validateOperationalEvent(event);
      const builtEvent = buildActionEvent(this._productInfo, this._tenantInfo, this._userInfo, event, eventType.OPERATIONAL, this._tabTracking.getCurrentTabId(), this._sessionTracking.getCurrentSessionId(), this.task.getAllTaskSessions(), this._orgInfo);

      this._processEvent(buildActionName(event), builtEvent, this._context, wrapCallback(callback, builtEvent));
    });

    _defineProperty(this, "startUIViewedEvent", callback => {
      this.stopUIViewedEvent();
      this._uiViewedEvent = new UIViewedEvent(this._productInfo, () => ({
        embeddedProduct: this._productInfo.embeddedProduct(),
        subproduct: this._productInfo.subproduct(),
        tenantIdType: this._tenantInfo.tenantIdType,
        tenantId: this._tenantInfo.tenantId,
        userId: this._userInfo.userId,
        lastScreenEvent: this._getLastScreenEvent(),
        attributes: this._uiViewedAttributes
      }), event => this.sendUIEvent(event, callback));

      this._uiViewedEvent.start();
    });

    _defineProperty(this, "stopUIViewedEvent", () => {
      if (this._uiViewedEvent) {
        this._uiViewedEvent.stop();

        this._uiViewedEvent = null;
      }
    });

    _defineProperty(this, "resetUIViewedTimers", () => {
      if (this._uiViewedEvent) {
        this._uiViewedEvent.resetTimers();
      }
    });

    _defineProperty(this, "startApdexEvent", apdexEvent => {
      this._apdexEvent.start(apdexEvent);
    });

    _defineProperty(this, "getApdexStart", apdexEvent => this._apdexEvent.getStart(apdexEvent));

    _defineProperty(this, "stopApdexEvent", (apdexEvent, callback) => {
      this._apdexEvent.stop(apdexEvent, callback);
    });

    _defineProperty(this, "startLowPriorityEventDelay", timeout => {
      if (timeout !== undefined && (Number.isNaN(timeout) || timeout <= 0)) {
        throw new Error(`Invalid timeout period: ${timeout}, must be a number greater than 0`);
      }

      if (this._delayTimeout) {
        clearTimeout(this._delayTimeout);
      }

      const delayTimeoutPeriod = timeout ? Math.min(timeout, MAX_DELAY_TIMEOUT) : MAX_DELAY_TIMEOUT;
      this._delayTimeout = setTimeout(() => this.stopLowPriorityEventDelay(), delayTimeoutPeriod); // If the queue is still flushing from a previous delay period, then we should cancel that flush
      // to stop it from negatively impacting the performance of the new critical section

      this._delayQueue.cancelFlush();

      this._isDelayingLowPriorityEvents = true;
    });

    _defineProperty(this, "stopLowPriorityEventDelay", () => {
      if (this._delayTimeout) {
        clearTimeout(this._delayTimeout);
        this._delayTimeout = null;
      }

      this._delayQueue.startFlush();

      this._isDelayingLowPriorityEvents = false;
    });

    _defineProperty(this, "onEvent", (analyticsId, analyticsData) => {
      if (!analyticsData) {
        throw new Error('Missing analyticsData');
      }

      if (!analyticsData.eventType) {
        throw new Error('Missing analyticsData.eventType');
      }

      if (!isType(eventType, analyticsData.eventType)) {
        throw new Error(`Invalid analyticsData.eventType '${analyticsData.eventType}', ` + `must be an eventType: [${objectValues(eventType)}]`);
      }

      if (analyticsData.eventType === eventType.TRACK) {
        this.sendTrackEvent(analyticsData);
      } else if (analyticsData.eventType === eventType.UI) {
        this.sendUIEvent(analyticsData);
      } else if (analyticsData.eventType === eventType.OPERATIONAL) {
        this.sendOperationalEvent(analyticsData);
      } else if (analyticsData.eventType === eventType.SCREEN) {
        this.sendScreenEvent(analyticsData.name, null, analyticsData.attributes);
      } else if (analyticsData.eventType === eventType.IDENTIFY) {
        this.sendIdentifyEvent(analyticsData.userIdType, analyticsData.userId);
      }
    });

    if (!productInfo) {
      throw new Error('Missing productInfo');
    }

    if (!productInfo.env) {
      throw new Error('Missing productInfo.env');
    }

    if (!productInfo.product) {
      throw new Error('Missing productInfo.product');
    }

    if (!isType(envType, productInfo.env)) {
      throw new Error(`Invalid productInfo.env '${productInfo.env}', ` + `must be an envType: [${objectValues(envType)}]`);
    }

    if (!productInfo.origin) {
      productInfo.origin = originType.WEB;
    } else if (!isType(originType, productInfo.origin)) {
      throw new Error(`Invalid productInfo.origin '${productInfo.origin}', ` + `must be an originType: [${objectValues(originType)}]`);
    }

    if (!productInfo.platform) {
      productInfo.platform = productInfo.origin === originType.WEB ? platformType.WEB : platformType.DESKTOP;
    } else {
      validatePlatform(productInfo);
    }

    const analytics = new Analytics();
    this._productInfo = _objectSpread(_objectSpread({}, productInfo), {}, {
      subproduct: this._createSubproductGetter(productInfo.subproduct),
      embeddedProduct: this._createEmbeddedProductGetter(productInfo.embeddedProduct)
    });
    this._tenantInfo = {};
    this._orgInfo = {};
    this._userInfo = {
      anonymousId: analytics.user().anonymousId()
    };
    this._uiViewedAttributes = {};
    this._context = buildContext(this._productInfo);
    this._safeSessionStorage = new SafeSessionStorage();

    const _useStargate = this._useStargate(settings.useStargate);

    const apiHost = settings.apiHost || this._selectHost({
      useStargate: _useStargate,
      env: productInfo.env,
      useLegacyUrl: settings.useLegacyUrl
    });

    const maxRetryAttempts = settings.maxRetryAttempts || 4;
    const minRetryDelay = settings.minRetryDelay || 1000;
    const resilienceMechanism = settings.resilienceMechanism || ResilienceMechanism.LOCALSTORAGE;

    const xidPromiseGetter = () => {
      if (settings.xidConsent) {
        const timeoutXidCallback = () => [{
          type: 'xc',
          state: 'TIMEOUT'
        }, {
          type: 'uid',
          state: 'TIMEOUT'
        }];

        const unknownXidCallback = () => [{
          type: 'xc',
          state: 'UNKNOWN'
        }, {
          type: 'uid',
          state: 'UNKNOWN'
        }];

        const P = Promise || PPromise;
        return P.race([// @ts-ignore XID wants their enum used specifically when we are supplying the exact string
        new XID(productInfo.env, XID_TIMEOUT).getXidCallbackForPromise().catch(() => unknownXidCallback), new P(resolve => {
          setTimeout(() => resolve(timeoutXidCallback), XID_TIMEOUT);
        })]);
      }

      return undefined;
    };

    analytics.use(BeforeSendIntegration);
    analytics.use(SegmentIO);
    analytics.init({
      BeforeSend: {},
      'Segment.io': {
        apiKey: settings.apiKey || '',
        apiHost,
        retryQueue: true,
        retryQueuePrefix: `awc-${productInfo.env}`,
        addBundledMetadata: true,
        unbundledIntegrations: ['Amplitude'],
        retryQueueOptions: {
          maxRetryDelay: 60000,
          minRetryDelay,
          backoffFactor: 2,
          maxAttempts: maxRetryAttempts,
          maxItems: 100,
          flushBeforeUnload: settings.flushBeforeUnload,
          resilienceMechanism
        },
        product: productInfo.product,
        xidPromiseGetter
      }
    }, {
      cookie: {
        secure: window.location.protocol === 'https:'
      },
      user: {
        // Stop the userId from persisting even after the user has logged out
        persist: false,
        // Stop the userId from being loaded from cookies set by other Segment clients
        cookie: {},
        // Stop the userId from being loaded from localStorage set by other Segment clients
        localStorage: {},
        localStorageFallbackDisabled: true
      }
    });
    this._analytics = analytics;
    this._pageVisibility = new PageVisibility();
    this._tabTracking = new TabTracking();
    this._sessionTracking = new SessionTracking({
      sessionExpiryTime: settings.sessionExpiryTime
    });
    this.task = new TaskSessionStore();
    this.originTracing = new OriginTracing(); // Init Apdex

    this._apdexEvent = new ApdexEvent(this.sendOperationalEvent, this._pageVisibility);
    this._historyReplaceFn = typeof settings.historyReplaceFn === 'function' ? settings.historyReplaceFn : defaultHistoryReplaceFn;
    this._delayQueue = new EventDelayQueue(this._fireDelayedEvent, settings.delayQueueCompressors);
    this._testingCache = new TestingCache();
  }

}