import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _defineProperty from "@babel/runtime/helpers/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import jsonStringfy from 'fast-json-stable-stringify';
import Fetcher from '../fetcher';
import { ResponseError } from '../fetcher/errors';
import { ClientCauseReason, ClientUserState } from '../fetcher/types';
import getLogger from '../logger';
import MetadataManager from './MetadataManager';
import { RefreshStatus } from './types';
import { flagResponseToFlagUpdate } from './util';
export var SCHEDULER_OPTIONS_DEFAULT = {
  minWaitInterval: 300000,
  // 300 second = 5 mins
  maxWaitInterval: 1200000,
  // 1200 second = 20 mins
  backOffFactor: 2,
  backOffJitter: 0.1,
  // Jitter is upto 10% of wait time
  interval: 300000,
  // 300 second = 5 mins
  tabHiddenPollingFactor: 12,
  // for hidden tabs, use hiddenTabFactor * interval for polling = 1 hour (default)
  maxInstantRetryTimes: 0
};
export var NO_CACHE_RETRY_OPTIONS_DEFAULT = _objectSpread(_objectSpread({}, SCHEDULER_OPTIONS_DEFAULT), {}, {
  minWaitInterval: 500,
  interval: 500,
  maxInstantRetryTimes: 1
});

var Refresh = /*#__PURE__*/function () {
  function Refresh(apiKey, env, user, onFeatureFlagUpdate, pollingConfig, version) {
    var lastUpdateTimestamp = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
    var onError = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : function () {};
    var noCachePollingConfig = arguments.length > 8 ? arguments[8] : undefined;

    _classCallCheck(this, Refresh);

    _defineProperty(this, "failureCount", 0);

    this.logger = getLogger();
    this.user = user;
    this.onFeatureFlagUpdate = onFeatureFlagUpdate;
    this.version = version;
    this.lastUpdateTimestamp = lastUpdateTimestamp;
    this.pollingConfig = {
      minWaitInterval: (pollingConfig === null || pollingConfig === void 0 ? void 0 : pollingConfig.minWaitInterval) || SCHEDULER_OPTIONS_DEFAULT.minWaitInterval,
      maxWaitInterval: (pollingConfig === null || pollingConfig === void 0 ? void 0 : pollingConfig.maxWaitInterval) || SCHEDULER_OPTIONS_DEFAULT.maxWaitInterval,
      backOffFactor: (pollingConfig === null || pollingConfig === void 0 ? void 0 : pollingConfig.backOffFactor) || SCHEDULER_OPTIONS_DEFAULT.backOffFactor,
      backOffJitter: (pollingConfig === null || pollingConfig === void 0 ? void 0 : pollingConfig.backOffJitter) !== undefined ? pollingConfig.backOffJitter : SCHEDULER_OPTIONS_DEFAULT.backOffJitter,
      interval: (pollingConfig === null || pollingConfig === void 0 ? void 0 : pollingConfig.interval) || SCHEDULER_OPTIONS_DEFAULT.interval,
      tabHiddenPollingFactor: (pollingConfig === null || pollingConfig === void 0 ? void 0 : pollingConfig.tabHiddenPollingFactor) || SCHEDULER_OPTIONS_DEFAULT.tabHiddenPollingFactor,
      maxInstantRetryTimes: 0 // Force this to 0 so this never reschdules instantly with cache

    };
    this.noCachePollingConfig = {
      minWaitInterval: (noCachePollingConfig === null || noCachePollingConfig === void 0 ? void 0 : noCachePollingConfig.minWaitInterval) || NO_CACHE_RETRY_OPTIONS_DEFAULT.minWaitInterval,
      maxWaitInterval: (noCachePollingConfig === null || noCachePollingConfig === void 0 ? void 0 : noCachePollingConfig.maxWaitInterval) || NO_CACHE_RETRY_OPTIONS_DEFAULT.maxWaitInterval,
      backOffFactor: (noCachePollingConfig === null || noCachePollingConfig === void 0 ? void 0 : noCachePollingConfig.backOffFactor) || NO_CACHE_RETRY_OPTIONS_DEFAULT.backOffFactor,
      backOffJitter: (noCachePollingConfig === null || noCachePollingConfig === void 0 ? void 0 : noCachePollingConfig.backOffJitter) !== undefined ? noCachePollingConfig.backOffJitter : NO_CACHE_RETRY_OPTIONS_DEFAULT.backOffJitter,
      interval: (noCachePollingConfig === null || noCachePollingConfig === void 0 ? void 0 : noCachePollingConfig.interval) || NO_CACHE_RETRY_OPTIONS_DEFAULT.interval,
      tabHiddenPollingFactor: (pollingConfig === null || pollingConfig === void 0 ? void 0 : pollingConfig.tabHiddenPollingFactor) || SCHEDULER_OPTIONS_DEFAULT.tabHiddenPollingFactor,
      maxInstantRetryTimes: (noCachePollingConfig === null || noCachePollingConfig === void 0 ? void 0 : noCachePollingConfig.maxInstantRetryTimes) !== undefined ? noCachePollingConfig.maxInstantRetryTimes : NO_CACHE_RETRY_OPTIONS_DEFAULT.maxInstantRetryTimes
    };
    this.onError = onError;
    this.fetcher = new Fetcher(apiKey, env);
    this.metadataManager = new MetadataManager(this.pollingConfig);
    this.status = RefreshStatus.INITIALISED;
    this.updateMetadataOnInitialisation();
    this.visibilityChangeHandler = this.visibilityChangeHandler.bind(this);
  } // start refresh by fetchAndReschedule


  _createClass(Refresh, [{
    key: "start",
    value: function start() {
      this.stop();
      this.bindVisibilityChange();
      this.fetchAndReschedule();
    } // cancel pending schedule

  }, {
    key: "stop",
    value: function stop() {
      if (this.timerId) {
        window.clearTimeout(this.timerId);
        this.timerId = undefined;
        this.unbindVisibilityChange();
      }
    } // update user, with optional version and timestamp

  }, {
    key: "updateUserContext",
    value: function updateUserContext(user, version) {
      var lastUpdateTimestamp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      this.user = user;
      this.version = version;
      this.lastUpdateTimestamp = lastUpdateTimestamp;
      this.failureCount = 0;
      this.updateMetadataOnUserChange();
    } // update version and timestamp

  }, {
    key: "setVersionAndTimestamp",
    value: function setVersionAndTimestamp(version, lastUpdateTimestamp) {
      this.version = version;
      this.lastUpdateTimestamp = lastUpdateTimestamp;
    }
  }, {
    key: "getStatus",
    value: function getStatus() {
      return this.status;
    }
  }, {
    key: "visibilityChangeHandler",
    value: function visibilityChangeHandler() {
      // cancel existing schedule
      window.clearTimeout(this.timerId);
      this.timerId = undefined; // get current tab hidden state (for unsupported browser isTabHidden() will return false), so
      // if isTabHidden true: create a new schedule with a longer interval
      // if isTabHidden false: do a fetchAndReschedule (conditional do a fetch, schedule with normal interval)

      if (Refresh.isTabHidden()) {
        this.schedule();
      } else {
        this.fetchAndReschedule();
      }
    }
  }, {
    key: "bindVisibilityChange",
    value: // bind tab visibility change callback
    function bindVisibilityChange() {
      document.addEventListener('visibilitychange', this.visibilityChangeHandler);
    } // unbind tab visibility change callback

  }, {
    key: "unbindVisibilityChange",
    value: function unbindVisibilityChange() {
      document.removeEventListener('visibilitychange', this.visibilityChangeHandler);
    } // schedule a fetchAndReschedule

  }, {
    key: "schedule",
    value: function schedule() {
      var _this = this;

      this.timerId = window.setTimeout(function () {
        _this.fetchAndReschedule();
      }, this.calculateInterval());
    } // conditional fetch ffs via fetcher, and schedule another fetchAndReschedule unless we have 400/401 from ffs

  }, {
    key: "fetchAndReschedule",
    value: function fetchAndReschedule() {
      var _this2 = this;

      var fetchedUser = jsonStringfy(this.user);

      if (this.isFetchRequired()) {
        this.fetcher.fetchFeatureFlags(this.user, this.metadataManager.get(), this.version).then(function (resp) {
          if (fetchedUser === jsonStringfy(_this2.user)) {
            _this2.failureCount = 0;

            _this2.onFeatureFlagUpdate(flagResponseToFlagUpdate(resp));

            _this2.schedule();

            _this2.status = RefreshStatus.SUCCESS;
          }

          _this2.updateMetadataOnRequestComplete();
        }).catch(function (err) {
          // 401 means client info or apiKey invalid, will have no retry
          // 400 means version data or request body invalid, will have at most `maxInstantRetryTimes` instant retries
          // other 4xx or 5xx will do `maxInstantRetryTimes` instant retries and continue to do backoff retries
          if (err instanceof ResponseError && err.status === 401) {
            // no retry needed
            var message = "Feature flag service returned ".concat(err.status, ", \"").concat(err.body, "\". This request will not be retried until the user data has been changed.");

            _this2.logger.error(message);

            _this2.onError(err.status, err.body);
          } else if (err instanceof ResponseError && err.status === 400) {
            if (_this2.version) {
              // 400 could be caused by corrupted version data, so clear it and schedule a retry
              _this2.failureCount += 1; // a user with no cache will retry instantly for maxInstantRetryTimes
              // onError will be called after all allowed attempts fail

              if (_this2.failureCount > _this2.getPollingConfig().maxInstantRetryTimes) {
                _this2.onError(err.status, err.body);
              }

              _this2.logger.error("Feature flag service returned ".concat(err.status, ", \"").concat(err.body, "\". Clear version data and retry."));

              _this2.setVersionAndTimestamp(undefined, 0);

              _this2.schedule();
            } else {
              // no retry needed
              var _message = "Feature flag service returned ".concat(err.status, ", \"").concat(err.body, "\". This request will not be retried until the user data has been changed.");

              _this2.logger.error(_message);

              _this2.onError(err.status, err.body);
            }
          } else if (err.name === 'AbortError') {
            _this2.failureCount += 1; // a user with no cache will retry instantly for maxInstantRetryTimes
            // onError will be called after all allowed attempts fail or timeout

            if (_this2.failureCount > _this2.getPollingConfig().maxInstantRetryTimes) {
              _this2.onError(0);
            }

            _this2.schedule();
          } else {
            _this2.failureCount += 1; // a user with no cache will retry instantly for maxInstantRetryTimes
            // onError will be called after all allowed attempts fail or timeout

            if (_this2.failureCount > _this2.getPollingConfig().maxInstantRetryTimes) {
              if (err instanceof ResponseError) {
                _this2.onError(err.status, err.body);
              } else {
                _this2.onError();
              }
            }

            _this2.schedule();
          }

          _this2.status = RefreshStatus.ERROR;

          _this2.updateMetadataOnRequestComplete();
        });
      } else {
        this.schedule();
        this.status = RefreshStatus.SUCCESS;
      }
    }
  }, {
    key: "isFetchRequired",
    value: function isFetchRequired() {
      return Date.now() - this.getPollingConfig().interval >= this.lastUpdateTimestamp;
    }
  }, {
    key: "updateMetadataOnUserChange",
    value: function updateMetadataOnUserChange() {
      // if fetch required, it will be a INITIALIZATION fetch, otherwise it's going to be a delay POLLING fetch
      this.metadataManager.updateClientCauseReason(this.isFetchRequired() ? ClientCauseReason.INITIALIZATION : ClientCauseReason.POLLING); // always set user state to SWITCHED user for next fetch

      this.metadataManager.updateClientUserState(ClientUserState.SWITCHED);
    }
  }, {
    key: "updateMetadataOnInitialisation",
    value: function updateMetadataOnInitialisation() {
      // if fetch required, it will be a INITIALIZATION fetch, otherwise it's going to be a delay POLLING fetch
      this.metadataManager.updateClientCauseReason(this.isFetchRequired() ? ClientCauseReason.INITIALIZATION : ClientCauseReason.POLLING); // no cache (lastUpdateTimestamp === 0) means we fetch for NEW user, if we have cache we fetch for SAME user

      this.metadataManager.updateClientUserState(this.lastUpdateTimestamp === 0 ? ClientUserState.NEW : ClientUserState.SAME);
    }
  }, {
    key: "updateMetadataOnRequestComplete",
    value: function updateMetadataOnRequestComplete() {
      if (this.failureCount) {
        // when current fetch failed, next fetch will be a RETRY
        // the calling user has not changed
        this.metadataManager.updateClientCauseReason(ClientCauseReason.RETRY);
      } else {
        // when current fetch success, next fetch will be a POLLING
        // and the calling user will be SAME user
        this.metadataManager.updateClientCauseReason(ClientCauseReason.POLLING);
        this.metadataManager.updateClientUserState(ClientUserState.SAME);
      }
    } // calculate wait interval based on failure count

  }, {
    key: "calculateInterval",
    value: function calculateInterval() {
      var _this$getPollingConfi = this.getPollingConfig(),
          interval = _this$getPollingConfi.interval,
          tabHiddenPollingFactor = _this$getPollingConfi.tabHiddenPollingFactor,
          minWaitInterval = _this$getPollingConfi.minWaitInterval,
          maxWaitInterval = _this$getPollingConfi.maxWaitInterval,
          backOffFactor = _this$getPollingConfi.backOffFactor,
          backOffJitter = _this$getPollingConfi.backOffJitter,
          maxInstantRetryTimes = _this$getPollingConfi.maxInstantRetryTimes;

      if (maxInstantRetryTimes !== undefined && maxInstantRetryTimes !== 0 && maxInstantRetryTimes >= this.failureCount) {
        return 0;
      }

      if (this.failureCount === 0) {
        return Refresh.isTabHidden() ? interval * tabHiddenPollingFactor : interval;
      }

      var ms = minWaitInterval * Math.pow(backOffFactor, this.failureCount - 1);

      if (backOffJitter) {
        var rand = Math.random();
        var deviation = Math.floor(rand * backOffJitter * ms);

        if (Math.floor(rand * 10) < 5) {
          ms -= deviation;
        } else {
          ms += deviation;
        }
      }

      return Number(Math.min(ms, maxWaitInterval));
    }
  }, {
    key: "getPollingConfig",
    value: function getPollingConfig() {
      if (this.version === undefined && this.lastUpdateTimestamp === 0) {
        return this.noCachePollingConfig;
      }

      return this.pollingConfig;
    }
  }], [{
    key: "isTabHidden",
    value: function isTabHidden() {
      return document.visibilityState === 'hidden';
    }
  }]);

  return Refresh;
}();

export { Refresh as default };