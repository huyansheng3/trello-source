import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import { ReadyReason } from '../api/types';
export var DEFAULT_PROMISE_TIMEOUT = 3 * 1000;
export var CLIENT_TIMEOUT = {
  reason: ReadyReason.CLIENT_ERROR,
  message: 'Client timed out.'
};
export var REQUEST_TIMEOUT = {
  reason: ReadyReason.CLIENT_ERROR,
  message: 'Request took too long to finish, client aborted the request.'
};
export var READY_CACHE = {
  reason: ReadyReason.CACHE
};
export var READY_FETCH = {
  reason: ReadyReason.FETCH
};

var Ready = /*#__PURE__*/function () {
  function Ready() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        readyTimeoutInMilliseconds = _ref.readyTimeoutInMilliseconds;

    _classCallCheck(this, Ready);

    this.readyTimeoutInMilliseconds = readyTimeoutInMilliseconds || DEFAULT_PROMISE_TIMEOUT;
    this.initialisePromise();
    this.initialiseDefaultPromise(this.readyTimeoutInMilliseconds);
  }

  _createClass(Ready, [{
    key: "initialiseDefaultPromise",
    value: function initialiseDefaultPromise(timeout) {
      this.defaultReadyPromise = new Promise(function (resolve) {
        setTimeout(function () {
          resolve({
            reason: ReadyReason.CLIENT_ERROR,
            message: 'Client timed out.'
          });
        }, timeout);
      });
    }
  }, {
    key: "initialisePromise",
    value: function initialisePromise() {
      var _this = this;

      /*
        A promise can only be resolved by calling the `resolve` function in the constructor callback.
        Since we need resolve the promise by external input, we must save the reference to this resolve function.
        This is safe as the callback function is called synchronously as defined by the ES spec.
      */
      this.readyPromise = new Promise(function (resolve) {
        _this.resolveReadyPromise = resolve;
      });
    }
  }, {
    key: "getPromise",
    value: function getPromise() {
      return Promise.race([this.readyPromise, this.defaultReadyPromise]);
    }
  }, {
    key: "triggerReady",
    value: function triggerReady(response) {
      if (this.resolveReadyPromise !== undefined) {
        this.resolveReadyPromise(response);
        this.resolveReadyPromise = undefined;
      }
    }
  }, {
    key: "reset",
    value: function reset() {
      if (this.resolveReadyPromise === undefined) {
        this.initialisePromise();
      }

      this.initialiseDefaultPromise(this.readyTimeoutInMilliseconds);
    }
  }]);

  return Ready;
}();

export { Ready as default };