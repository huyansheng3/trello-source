import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import jsonStringfy from 'fast-json-stable-stringify';
import { ReadyReason } from '../api/types';
import ExposureEvents from '../exposureEvents';
import getLogger from '../logger';
import Storage from '../storage';
import Subscriptions, { Broadcast } from '../subscriptions';
import cloneObject from '../util/clone-object';
import Anonymous from './Anonymous';
import Ready, { READY_CACHE, READY_FETCH } from './Ready';
import Refresh from './Refresh';
import { flagStateToFlagUpdate, getReadyMessageForStatusCode, getReasonForStatusCode, hasFlagValueChanged, validateConstructorArgs, validateDefaultValue, validateFlag } from './util';
export var STORAGE_PURE_TIMEOUT = 10000;

var Client = /*#__PURE__*/function () {
  function Client(apiKey, analyticsWebClient, originalFeatureFlagUser, options) {
    var _this = this;

    _classCallCheck(this, Client);

    // Should be done ASAP to prevent calls to console before usage
    getLogger(options === null || options === void 0 ? void 0 : options.loggerOptions);
    validateConstructorArgs(apiKey, analyticsWebClient, originalFeatureFlagUser, options);
    var featureFlagUser = cloneObject(originalFeatureFlagUser);
    var user = Anonymous.processAnonymousUser(featureFlagUser);
    this.featureFlagUpdateBroadcastHandler = this.featureFlagUpdateBroadcastHandler.bind(this);
    this.featureFlagUpdateHttpHandler = this.featureFlagUpdateHttpHandler.bind(this);
    this.featureFlagUpdateFailedHandler = this.featureFlagUpdateFailedHandler.bind(this);
    this.readyResolver = new Ready({
      readyTimeoutInMilliseconds: options.readyTimeoutInMilliseconds
    });
    this.exposureEvents = new ExposureEvents(analyticsWebClient);
    this.storage = new Storage(options.environment, options.productKey, apiKey, user);
    this.broadcast = new Broadcast(apiKey, user, this.featureFlagUpdateBroadcastHandler);
    this.restoreFlagStateFromStorage();
    this.userData = user;
    this.refresh = new Refresh(apiKey, options.environment, this.userData, this.featureFlagUpdateHttpHandler, {
      interval: options.pollingInterval
    }, this.dataVersion, this.lastUpdatedTimestamp, this.featureFlagUpdateFailedHandler);
    this.refresh.start();
    this.subscriptions = new Subscriptions();
    setTimeout(function () {
      return _this.storage.purgeStaleFlagState();
    }, STORAGE_PURE_TIMEOUT);
  }

  _createClass(Client, [{
    key: "ready",
    value: function ready() {
      return this.readyResolver.getPromise();
    }
  }, {
    key: "getFlagValue",
    value: function getFlagValue(flagKey, defaultValue, options) {
      var validatedFlag = this.getFlagDetails(flagKey, defaultValue, options);
      return validatedFlag.value;
    }
  }, {
    key: "getFlagDetails",
    value: function getFlagDetails(flagKey, defaultValue, options) {
      validateDefaultValue(defaultValue);
      var flag = this.flags[flagKey];
      var validatedFlag = validateFlag(flag, defaultValue, this.refresh.getStatus(), options);

      if (options !== null && options !== void 0 && options.shouldSendExposureEvent) {
        this.exposureEvents.sendExposureEvent(flagKey, validatedFlag.value, validatedFlag.evaluationDetail, options.exposureData);
      }

      return validatedFlag;
    }
  }, {
    key: "getFlags",
    value: function getFlags() {
      return cloneObject(this.flags);
    }
  }, {
    key: "on",
    value: function on(flagKey, defaultValue, callback, options) {
      validateDefaultValue(defaultValue);
      return this.subscriptions.on(flagKey, defaultValue, callback, this.getFlagValue.bind(this), options);
    }
  }, {
    key: "onAnyFlagUpdated",
    value: function onAnyFlagUpdated(callback) {
      return this.subscriptions.onAnyFlagUpdated(callback);
    }
  }, {
    key: "updateFeatureFlagUser",
    value: function updateFeatureFlagUser(originalFeatureFlagUser) {
      if (!originalFeatureFlagUser) {
        throw new Error('featureFlagUser is missing');
      }

      var featureFlagUser = cloneObject(originalFeatureFlagUser);
      var user = Anonymous.processAnonymousUser(featureFlagUser);

      if (jsonStringfy(this.userData) === jsonStringfy(user)) {
        return this.ready();
      }

      this.readyResolver.reset();
      this.userData = user;
      this.storage.updateUserContext(user);
      var storedData = this.storage.getFlagsState();

      if (storedData) {
        var changedFlagKeys = this.updateInMemoryFlags(flagStateToFlagUpdate(this.flags, storedData));
        this.sendSubscriptionUpdates(changedFlagKeys);
        this.readyResolver.triggerReady(READY_CACHE);
      }

      this.lastUpdatedTimestamp = (storedData === null || storedData === void 0 ? void 0 : storedData.timestamp) || 0;
      this.dataVersion = storedData === null || storedData === void 0 ? void 0 : storedData.version;
      this.refresh.stop();
      this.refresh.updateUserContext(user, this.dataVersion, this.lastUpdatedTimestamp);
      this.refresh.start();
      this.broadcast.updateUserContext(user);
      return this.ready();
    }
  }, {
    key: "addFlag",
    value: function addFlag(flagKey, flag) {
      this.flags[flagKey] = flag;
    } // Convenience API, not official

  }, {
    key: "destroy",
    value: function destroy() {
      this.refresh.stop();
      this.subscriptions.stop();
      this.broadcast.stop();
      this.readyResolver.triggerReady({
        reason: ReadyReason.CLIENT_ERROR,
        message: 'Client got destroyed.'
      });
    }
  }, {
    key: "restoreFlagStateFromStorage",
    value: function restoreFlagStateFromStorage() {
      var storedData = this.storage.getFlagsState();
      this.flags = (storedData === null || storedData === void 0 ? void 0 : storedData.flags) || {};
      this.lastUpdatedTimestamp = (storedData === null || storedData === void 0 ? void 0 : storedData.timestamp) || 0;
      this.dataVersion = storedData === null || storedData === void 0 ? void 0 : storedData.version;

      if (storedData !== null && storedData !== undefined) {
        this.readyResolver.triggerReady(READY_CACHE);
      }
    }
  }, {
    key: "getCurrentFeatureFlagState",
    value: function getCurrentFeatureFlagState() {
      return {
        timestamp: this.lastUpdatedTimestamp,
        version: this.dataVersion,
        flags: this.flags
      };
    }
  }, {
    key: "featureFlagUpdateFailedHandler",
    value: function featureFlagUpdateFailedHandler(statusCode, rawBody) {
      this.readyResolver.triggerReady({
        reason: getReasonForStatusCode(statusCode),
        message: getReadyMessageForStatusCode(statusCode),
        serverResponse: rawBody
      });
    }
  }, {
    key: "featureFlagUpdateHttpHandler",
    value: function featureFlagUpdateHttpHandler(update) {
      if (this.dataVersion) {
        this.processFeatureFlagUpdate(update);
      } else {
        // If dataVersion is undefined, then the request had no versionData.
        // This would mean that the API cannot tell us what flags to delete,
        // and has just given us every flag available at its latest state.
        // We should replace all flags instead of merging the flags.
        this.processFeatureFlagUpdate(flagStateToFlagUpdate(this.flags, update));
      } // broadcast the flag state to other tabs


      this.broadcast.sendFeatureFlagState(this.getCurrentFeatureFlagState());
    }
  }, {
    key: "featureFlagUpdateBroadcastHandler",
    value: function featureFlagUpdateBroadcastHandler(featureFlagState) {
      // return if broadcasted ff state is stale
      if (featureFlagState.timestamp < this.lastUpdatedTimestamp) {
        return;
      }

      this.processFeatureFlagUpdate(flagStateToFlagUpdate(this.flags, featureFlagState));
    }
  }, {
    key: "processFeatureFlagUpdate",
    value: function processFeatureFlagUpdate(update) {
      this.lastUpdatedTimestamp = Date.now();
      this.dataVersion = update.versionData || this.dataVersion;
      var changedFlagKeys = this.updateInMemoryFlags(update);
      this.sendSubscriptionUpdates(changedFlagKeys);
      this.refresh.setVersionAndTimestamp(this.dataVersion, this.lastUpdatedTimestamp);
      this.storage.setFlagsState(this.getCurrentFeatureFlagState());
      this.readyResolver.triggerReady(READY_FETCH);
    }
  }, {
    key: "updateInMemoryFlags",
    value: function updateInMemoryFlags(update) {
      var _update$deletedFlags,
          _this2 = this;

      var changedFlags = [];
      (_update$deletedFlags = update.deletedFlags) === null || _update$deletedFlags === void 0 ? void 0 : _update$deletedFlags.forEach(function (flagKey) {
        if (flagKey in _this2.flags) {
          delete _this2.flags[flagKey];
          changedFlags.push(flagKey);
        }
      });
      Object.keys(update.flags).forEach(function (flagKey) {
        if (hasFlagValueChanged(_this2.flags[flagKey], update.flags[flagKey])) {
          changedFlags.push(flagKey);
        }

        _this2.flags[flagKey] = update.flags[flagKey];
      });
      return changedFlags;
    }
  }, {
    key: "sendSubscriptionUpdates",
    value: function sendSubscriptionUpdates(changedFlagKeys) {
      var _this3 = this;

      if (changedFlagKeys.length > 0) {
        this.subscriptions.anyFlagUpdated();
        changedFlagKeys.forEach(function (flagKey) {
          return _this3.subscriptions.flagValueUpdated(flagKey);
        });
      }
    }
  }]);

  return Client;
}();

export { Client as default };