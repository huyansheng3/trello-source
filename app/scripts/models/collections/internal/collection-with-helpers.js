/* eslint-disable
          eqeqeq,
          @typescript-eslint/no-use-before-define,
*/
// Generated by CoffeeScript 1.12.7
/*
  Because of the way this file was decompiled, typescript cannot detect its type
  That is why we use `@ts-ignore` in every place we reference this.
  If you're here to convert it to a class, please make sure to clean all the related `@ts-ignore`s
*/
(function () {
  const extend = function (child, parent) {
    for (const key in parent) {
      if (hasProp.call(parent, key)) child[key] = parent[key];
    }
    function ctor() {
      this.constructor = child;
    }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
    child.__super__ = parent.prototype;
    return child;
  };
  const hasProp = {}.hasOwnProperty;
  const slice = [].slice;

  const Backbone = require('@trello/backbone');

  const Hearsay = require('hearsay');
  const { Util } = require('app/scripts/lib/util');
  const { ApiError } = require('app/scripts/network/api-error');

  const _ = require('underscore');

  const f = require('effing');

  const {
    Analytics,
    getScreenFromUrl,
  } = require('@trello/atlassian-analytics');

  const determinePossibleCardRole = require('@trello/card-roles')
    .determinePossibleCardRole;

  const featureFlagClient = require('@trello/feature-flag-client')
    .featureFlagClient;

  const CollectionWithHelpers = (function (superClass) {
    extend(CollectionWithHelpers, superClass);

    function CollectionWithHelpers(models, options) {
      this.modelCache = options != null ? options.modelCache : void 0;
      CollectionWithHelpers.__super__.constructor.apply(this, arguments);
    }

    CollectionWithHelpers.prototype.destructor = function () {
      this.stopListening();
      return Util.shred(this);
    };

    CollectionWithHelpers.prototype.create = function () {
      let arg, i, model, next, options, ref;
      (model = arguments[0]),
        (arg =
          3 <= arguments.length
            ? slice.call(arguments, 1, (i = arguments.length - 1))
            : ((i = 1), [])),
        (next = arguments[i++]);
      options = arg[0];
      if (!options && !_.isFunction(next)) {
        options = next;
        next = function () {};
      }
      if (options == null) {
        options = {};
      }
      const lockIndex = this.modelCache.lock('Collection Create');
      if (options.headers == null) {
        options.headers = {};
      }
      if (options.traceId) {
        options.headers['X-Trello-TraceId'] = options.traceId;
      }
      options.success = f.concat(
        (ref = options.success) != null ? ref : function () {},
        (function (_this) {
          return function (model) {
            return next(null, model);
          };
        })(this),
      );
      const customError = options.error;
      options.error = (function (_this) {
        return function (model, xhr, options) {
          const textStatus = xhr != null ? xhr.responseText : void 0;
          const status = xhr != null ? xhr.status : void 0;
          if (customError != null) {
            customError(status, textStatus);
          } else {
            Analytics.sendOperationalEvent({
              action: 'errored',
              actionSubject: 'hiddenServerError',
              source: getScreenFromUrl(),
              attributes: {
                textStatus,
              },
            });
          }
          return next(textStatus);
        };
      })(this);
      options.complete = f.choke(0, this.modelCache, 'unlock', lockIndex);
      if (options.modelCache == null) {
        options.modelCache = this.modelCache;
      }
      if (this.model.prototype.typeName === 'Card') {
        let cardRole = determinePossibleCardRole({
          name: model.name,
          description: model.desc,
          numAttachments: 0,
          numLabels: 0,
          numMembers: 0,
          numChecklistItems: 0,
          numCustomFieldItems: 0,
          startDate: model.start,
          dueDate: model.due,
          cover: model.cover,
        });

        if (
          cardRole === 'board' &&
          !featureFlagClient.get('wildcard.board-cards', false)
        ) {
          cardRole = null;
        }

        if (
          cardRole === 'mirror' &&
          !featureFlagClient.get('wildcard.mirror-cards', false)
        ) {
          cardRole = null;
        }

        if (
          cardRole === 'separator' &&
          !featureFlagClient.get('wildcard.card-types-separator', false)
        ) {
          cardRole = null;
        }

        if (
          cardRole === 'link' &&
          !featureFlagClient.get('wildcard.link-cards', false)
        ) {
          cardRole = null;
        }

        model.cardRole = cardRole;
      }
      return CollectionWithHelpers.__super__.create.call(this, model, options);
    };

    // Duplicating this.create with tracing instrumentation, eventually
    // we could move over to this method for all collections
    CollectionWithHelpers.prototype.createWithTracing = function () {
      let arg, i, model, next, options;
      (model = arguments[0]),
        (arg =
          3 <= arguments.length
            ? slice.call(arguments, 1, (i = arguments.length - 1))
            : ((i = 1), [])),
        (next = arguments[i++]);
      options = arg[0];
      if (!options && !_.isFunction(next)) {
        options = next;
        next = function () {};
      }
      if (options == null) {
        options = {};
      }
      const lockIndex = this.modelCache.lock('Collection Create');
      if (options.headers == null) {
        options.headers = {};
      }

      const traceId = options.traceId;
      if (traceId) {
        options.headers['X-Trello-TraceId'] = traceId;
        delete options.traceId;
      }

      const customSuccess = options.success;
      options.success = (model, xhrResponse, xhrOptions) => {
        const trelloServerVersion = xhrOptions?.xhr?.getResponseHeader(
          'X-Trello-Version',
        );
        Analytics.setTrelloServerVersion(traceId, trelloServerVersion);

        if (customSuccess) {
          customSuccess(model, xhrResponse, xhrOptions);
        }
        // order of arguments for "next" is different from what Backbone gives us, but this is to better reflect node-like callback systems
        return next(null, model);
      };

      const customError = options.error;
      options.error = (model, xhrResponse, xhrOptions) => {
        const status = xhrResponse != null ? xhrResponse.status : undefined;

        const errorMessage = ApiError.parseErrorMessage(xhrResponse);
        const error = ApiError.fromResponse(status, errorMessage);
        error.serverMessage = xhrResponse.responseJSON?.error;

        const trelloServerVersion = xhrOptions?.xhr?.getResponseHeader(
          'X-Trello-Version',
        );
        Analytics.setTrelloServerVersion(traceId, trelloServerVersion);

        if (customError) {
          customError(model, error, xhrResponse);
        }

        Analytics.sendOperationalEvent({
          action: 'errored',
          actionSubject: 'hiddenServerError',
          source: getScreenFromUrl(),
          attributes: {
            errorMessage,
            status,
            error,
          },
        });
        // order of arguments for "next" is different from what Backbone gives us, but this is to better reflect node-like callback systems
        return next(error, model);
      };

      options.complete = this.modelCache.unlock(lockIndex);
      if (options.modelCache == null) {
        options.modelCache = this.modelCache;
      }
      if (this.model.prototype.typeName === 'Card') {
        let cardRole = determinePossibleCardRole({
          name: model.name,
          description: model.desc,
          numAttachments: 0,
          numLabels: 0,
          numMembers: 0,
          numChecklistItems: 0,
          numCustomFieldItems: 0,
          startDate: model.start,
          dueDate: model.due,
          cover: model.cover,
        });

        if (
          cardRole === 'board' &&
          !featureFlagClient.get('wildcard.board-cards', false)
        ) {
          cardRole = null;
        }

        if (
          cardRole === 'mirror' &&
          !featureFlagClient.get('wildcard.mirror-cards', false)
        ) {
          cardRole = null;
        }

        if (
          cardRole === 'separator' &&
          !featureFlagClient.get('wildcard.card-types-separator', false)
        ) {
          cardRole = null;
        }

        if (
          cardRole === 'link' &&
          !featureFlagClient.get('wildcard.link-cards', false)
        ) {
          cardRole = null;
        }

        model.cardRole = cardRole;
      }

      return CollectionWithHelpers.__super__.create.call(this, model, options);
    };

    CollectionWithHelpers.prototype._update = function (newModels) {
      let oldIds;
      const shouldReset =
        newModels.length === this.models.length
          ? ((oldIds = {}),
            this.models.forEach(function (m) {
              return (oldIds[m.cid] = true);
            }),
            newModels.some(function (m) {
              return !oldIds[m.cid];
            }))
          : true;
      if (shouldReset) {
        return this.reset(newModels);
      }
    };

    CollectionWithHelpers.prototype.setOwner = function (owner) {
      this.owner = owner;
      return this;
    };

    CollectionWithHelpers.prototype.syncModel = function (
      sourceModel,
      attr,
      arg,
    ) {
      let ids = {};
      this.sourceModel = sourceModel;
      const fxGetIds = (arg != null ? arg : {}).fxGetIds;
      this.modelCache = this.sourceModel.modelCache;
      const getIds = (function (_this) {
        return function () {
          let ref, ref1;
          const attrValue = _this.sourceModel.get(attr);
          return (ref =
            (ref1 =
              typeof fxGetIds === 'function' ? fxGetIds(attrValue) : void 0) !=
            null
              ? ref1
              : attrValue) != null
            ? ref
            : [];
        };
      })(this);
      const update = (function (_this) {
        return function (collectionIds) {
          const models = _.chain(collectionIds)
            .map(function (id) {
              return _this.modelCache.get(_this.model, id);
            })
            .compact()
            .value();
          return _this._update(models);
        };
      })(this);
      this.sync = (function (_this) {
        return function () {
          let i, id, len;
          const newIds = getIds();
          ids = {};
          for (i = 0, len = newIds.length; i < len; i++) {
            id = newIds[i];
            ids[id] = true;
          }
          return update(newIds);
        };
      })(this);
      this.listenTo(this.sourceModel, 'change:' + attr, this.sync);
      this.listenTo(
        this.modelCache,
        'add:' + this.model.prototype.typeName,
        function (model) {
          if (ids[model.id]) {
            this.add(model);
          }
        },
      );
      this.listenTo(
        this.modelCache,
        'remove:' + this.model.prototype.typeName,
        function (model) {
          if (ids[model.id]) {
            this.remove(model);
          }
        },
      );
      this.sync();
      return this;
    };

    CollectionWithHelpers.prototype.syncCache = function (
      modelCache,
      watchedAttrs,
      pred,
    ) {
      let attr, i, len;
      this.modelCache = modelCache;
      this.sync = (function (_this) {
        return function () {
          return _this._update(_this.modelCache.all(_this.model).filter(pred));
        };
      })(this);
      const typeName = this.model.prototype.typeName;
      this.listenTo(
        this.modelCache,
        'add:' + typeName,
        (function (_this) {
          return function (model) {
            if (pred(model)) {
              return _this.add(model);
            }
          };
        })(this),
      );
      this.listenTo(
        this.modelCache,
        'remove:' + typeName,
        (function (_this) {
          return function (model) {
            if (pred(model)) {
              return _this.remove(model);
            }
          };
        })(this),
      );
      this.listenTo(this.modelCache, 'reset:' + typeName, this.sync);
      for (i = 0, len = watchedAttrs.length; i < len; i++) {
        attr = watchedAttrs[i];
        this.listenTo(
          this.modelCache,
          'change:' + typeName + ':' + attr,
          function (model) {
            if (pred(model)) {
              return this.add(model);
            } else {
              return this.remove(model);
            }
          },
        );
      }
      this.sync();
      return this;
    };

    CollectionWithHelpers.prototype.syncSubModels = function (
      sourceModel,
      attr,
      discardUnknown,
    ) {
      this.sourceModel = sourceModel;
      if (this.modelCache == null) {
        this.modelCache = this.sourceModel.modelCache;
      }
      this.sync = (function (_this) {
        return function () {
          let i, json, len, model, ref, ref1, subModel;
          const subModelsJSON =
            (ref = _this.sourceModel.get(attr)) != null ? ref : [];
          const newModels = function () {
            let i, len;
            const results = [];
            for (i = 0, len = subModelsJSON.length; i < len; i++) {
              json = subModelsJSON[i];
              subModel = _.find(this.models, function (m) {
                return m.id === json.id;
              });
              if (subModel != null) {
                this.modelCache.enqueueDelta(subModel, json);
              } else {
                subModel = new this.model(json, {
                  modelCache: this.modelCache,
                  collection: this,
                });
              }
              results.push(subModel);
            }
            return results;
          }.call(_this);
          if (!discardUnknown) {
            ref1 = _this.models;
            for (i = 0, len = ref1.length; i < len; i++) {
              model = ref1[i];
              if (model.id == null) {
                newModels.push(model);
              }
            }
          }
          return _this._update(newModels);
        };
      })(this);
      this.listenTo(this.sourceModel, 'change:' + attr, this.sync);
      this.sync();
      return this;
    };

    CollectionWithHelpers.prototype.snoop = function () {
      const attrs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      const events = ['add', 'remove', 'reset']
        .concat(
          attrs.map(function (attr) {
            return ['change', attr].join(':');
          }),
        )
        .join(' ');
      return new Hearsay.ContinuousSignal(
        (function (_this) {
          return function (send) {
            send(_this);
            const update = function () {
              return send(_this);
            };
            _this.listenTo(_this, events, update);
            return function () {
              return _this.stopListening(_this, events, update);
            };
          };
        })(this),
      );
    };

    return CollectionWithHelpers;
  })(Backbone.Collection);

  module.exports = CollectionWithHelpers;
}.call(this));
