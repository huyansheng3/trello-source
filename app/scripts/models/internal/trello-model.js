/* eslint-disable
      no-prototype-builtins,
            */
// Generated by CoffeeScript 1.12.7
/*
  Because of the way this file was decompiled, typescript cannot detect its type
  That is why we use `@ts-ignore` in every place we reference this.
  If you're here to convert it to a class, please make sure to clean all the related `@ts-ignore`s
*/
(function () {
  let client, ref, syncDeltaToCache;
  const hasProp = {}.hasOwnProperty,
    extend = function (child, parent) {
      for (const key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    },
    slice = [].slice,
    indexOf =
      [].indexOf ||
      function (item) {
        for (let i = 0, l = this.length; i < l; i++) {
          if (i in this && this[i] === item) return i;
        }
        return -1;
      };

  const { ApiAjax } = require('app/scripts/network/api-ajax');

  const { ApiError } = require('app/scripts/network/api-error');

  const { Analytics } = require('@trello/atlassian-analytics');

  const Backbone = require('@trello/backbone');

  const Hearsay = require('hearsay');

  const Promise = require('bluebird');

  const Queue = require('promise-queue');

  const { SchedulingMixin } = require('app/scripts/lib/scheduling-mixin');

  const { Util } = require('app/scripts/lib/util');

  const _ = require('underscore');

  const determinePossibleCardRole = require('@trello/card-roles')
    .determinePossibleCardRole;

  const classicUpdaterClient = require('app/scripts/network/classic-updater-client')
    .classicUpdaterClient;

  (ref = require('@trello/graphql')),
    (client = ref.client),
    (syncDeltaToCache = ref.syncDeltaToCache);

  const TrelloModel = (function (superClass) {
    extend(
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      TrelloModel,
      superClass,
    );

    function TrelloModel(attributes, options) {
      let ref1;
      if (this._lazyCache /* eslint-disable-line eqeqeq */ == null) {
        this._lazyCache = {};
      }
      this._marked = {};
      this._lockQueue = {};
      this.modelCache = options?.modelCache;
      this._apiQueue = new Queue(1);
      TrelloModel.__super__.constructor.apply(this, arguments);
      if ((ref1 = this.modelCache) /* eslint-disable-line eqeqeq */ != null) {
        ref1.add(this, {
          source: options?.source,
        });
      }
    }

    TrelloModel.prototype._initSubEventsOn = function (attr) {
      return this.listenTo(
        this,
        'change:' + attr,
        ((_this) => (model, newAttrs) => {
          let key, ref1, value;
          const oldAttrs =
            (ref1 = model.previousAttributes()) /* eslint-disable-line eqeqeq */ !=
            null
              ? ref1[attr]
              : undefined;
          const results = [];
          for (key in newAttrs) {
            value = newAttrs[key];
            if (
              oldAttrs /* eslint-disable-line eqeqeq */ == null ||
              value !== oldAttrs[key]
            ) {
              results.push(_this.trigger('change:' + attr + '.' + key));
            }
          }
          return results;
        })(this),
      );
    };

    TrelloModel.prototype.waitForLock = function (name, next) {
      const fxReleaseLock = ((_this) => () => {
        let fx;
        if (_.isEmpty(_this._lockQueue[name])) {
          return delete _this._lockQueue[name];
        } else {
          fx = _this._lockQueue[name].shift();
          return fx(fxReleaseLock);
        }
      })(this);
      if (this._lockQueue[name] /* eslint-disable-line eqeqeq */ != null) {
        return this._lockQueue[name].push(next);
      } else {
        this._lockQueue[name] = [];
        return next(fxReleaseLock);
      }
    };

    TrelloModel.prototype.set = function (attrs, options) {
      let child,
        children,
        cur,
        i,
        j,
        k,
        key,
        l,
        leaf,
        len,
        len1,
        parent,
        ref1,
        ref2,
        value;
      if (_.isArray(attrs)) {
        attrs = _.find(attrs, function (a) {
          return a.id === this.id || a._id === this.id;
        });
      }
      if (attrs?._id /* eslint-disable-line eqeqeq */ != null) {
        if (attrs.id /* eslint-disable-line eqeqeq */ == null) {
          attrs.id = attrs._id;
        }
        delete attrs._id;
      }
      const slashValues = (() => {
        const results = [];
        for (key in attrs) {
          value = attrs[key];
          if (key.indexOf('/') >= 0) {
            results.push([key, value]);
          }
        }
        return results;
      })();
      if (slashValues.length > 0) {
        attrs = _.clone(attrs);
        for (j = 0, len = slashValues.length; j < len; j++) {
          (ref1 = slashValues[j]), (key = ref1[0]), (value = ref1[1]);
          (ref2 = key.split('/')),
            (parent = ref2[0]),
            (children =
              3 <= ref2.length
                ? slice.call(ref2, 1, (k = ref2.length - 1))
                : ((k = 1), [])),
            (leaf = ref2[k++]);
          if (attrs[parent] /* eslint-disable-line eqeqeq */ == null) {
            attrs[parent] = _.clone(this.get(parent)) ?? {};
          }
          cur = attrs[parent];
          for (i = l = 0, len1 = children.length; l < len1; i = ++l) {
            child = children[i];
            cur = cur[child] = _.clone(cur[child]) ?? {};
          }
          cur[leaf] = value;
          delete attrs[key];
        }
      }
      if (options?.broadcast && this.id) {
        classicUpdaterClient.broadcast({
          typeName: this.typeName,
          delta: { id: this.id, ...attrs },
        });
      }
      return TrelloModel.__super__.set.apply(this, arguments);
    };

    TrelloModel.prototype.get = function (attr) {
      if (this.attributes) {
        return TrelloModel.__super__.get.apply(this, arguments);
      }
    };

    TrelloModel.lazy = function (map) {
      const properties = Object.entries(map).reduce(function (properties, arg) {
        let key;
        (key = arg[0]), arg[1];
        properties[key] = {
          get: function () {
            let collection;
            if (!this._lazyCache[key]) {
              collection = map[key].call(this);
              this.destruct(collection);
              this._lazyCache[key] = collection;
            }
            return this._lazyCache[key];
          },
          set: function (value) {
            throw new Error("Can't set a lazy list");
          },
        };
        return properties;
      }, {});
      return Object.defineProperties(this.prototype, properties);
    };

    TrelloModel.prototype.destructor = function () {
      let j, len, obj, ref1;
      this.stopListening();
      this.cancelScheduled();
      if (this._using /* eslint-disable-line eqeqeq */ != null) {
        ref1 = this._using;
        for (j = 0, len = ref1.length; j < len; j++) {
          obj = ref1[j];
          if (typeof obj.destructor === 'function') {
            obj.destructor();
          }
        }
      }
      return Util.shred(this);
    };

    TrelloModel.prototype.destroy = function () {
      TrelloModel.__super__.destroy.apply(this, arguments);
      return this.destructor();
    };

    TrelloModel.prototype.destroyWithTracing = function (
      { success, error, ...options },
      next,
    ) {
      if (!options.headers) {
        options.headers = {};
      }

      const traceId = options.traceId;
      if (traceId) {
        options.headers['X-Trello-TraceId'] = traceId;
        delete options.traceId;
      }

      this.destroy({
        ...options,
        success: (model, xhrResponse, xhrOptions) => {
          const trelloServerVersion = xhrOptions?.xhr?.getResponseHeader(
            'X-Trello-Version',
          );
          Analytics.setTrelloServerVersion(traceId, trelloServerVersion);

          if (success) {
            success(model, xhrResponse, xhrOptions);
          }
          return next(null, model);
        },
        error: (model, xhrResponse, xhrOptions) => {
          const trelloServerVersion = xhrOptions?.xhr?.getResponseHeader(
            'X-Trello-Version',
          );
          Analytics.setTrelloServerVersion(traceId, trelloServerVersion);

          if (error) {
            error(model, xhrResponse, xhrOptions);
          }
          const status = xhrResponse !== null ? xhrResponse.status : undefined;
          const errorMessage = ApiError.parseErrorMessage(xhrResponse);
          const apiError = ApiError.fromResponse(status, errorMessage);
          return next(apiError, model);
        },
      });
    };

    TrelloModel.prototype.destruct = function (objs) {
      let j, len, obj, results;
      if (!_.isArray(objs)) {
        return this.destruct([objs]);
      } else {
        if (this._using /* eslint-disable-line eqeqeq */ == null) {
          this._using = [];
        }
        results = [];
        for (j = 0, len = objs.length; j < len; j++) {
          obj = objs[j];
          results.push(this._using.push(obj));
        }
        return results;
      }
    };

    TrelloModel.load = function (
      id,
      payload,
      modelCache,
      isCachedModelValidPredicates = [],
    ) {
      const { ModelLoader } = require('app/scripts/db/model-loader');
      return Promise['try'](
        ((_this) => () => {
          let existingModel, fields;
          if (
            modelCache /* eslint-disable-line eqeqeq */ == null ||
            id /* eslint-disable-line eqeqeq */ == null
          ) {
            return null;
          }
          const onlyHas = (obj, allowedKeys) => {
            const keys = _.keys(obj);
            return !_.any(keys, (key) => indexOf.call(allowedKeys, key) < 0);
          };
          if (
            (!onlyHas(payload, ['query']) ||
              !onlyHas(payload.query, ['fields'])) &&
            _.isEmpty(isCachedModelValidPredicates)
          ) {
            return null;
          }
          if (
            (existingModel = modelCache.get(
              _this,
              id,
            )) /* eslint-disable-line eqeqeq */ != null
          ) {
            fields = payload.query.fields
              ? payload.query.fields.split(',')
              : [];
            if (
              _.all(fields, (field) =>
                existingModel.attributes.hasOwnProperty(field),
              ) &&
              _.all(isCachedModelValidPredicates, (predicate) =>
                predicate(existingModel),
              )
            ) {
              return existingModel;
            }
          }
          return null;
        })(this),
      ).then(
        ((_this) => (existingModel) => {
          if (existingModel /* eslint-disable-line eqeqeq */ != null) {
            return existingModel;
          }
          return ModelLoader.loadModel(_this, id, payload);
        })(this),
      );
    };

    TrelloModel.prototype.ready = function (callback) {
      if (!callback) {
        return;
      }
      if (this.isReady) {
        callback();
      } else {
        if (!this.waitingForReady) {
          this.waitingForReady = [];
        }
        this.waitingForReady.push(callback);
      }
    };

    TrelloModel.prototype.setReady = function () {
      let callback, j, len, waitingForReady;
      this.isReady = true;
      if (this.waitingForReady) {
        waitingForReady = this.waitingForReady;
        this.waitingForReady = null;
        for (j = 0, len = waitingForReady.length; j < len; j++) {
          callback = waitingForReady[j];
          if (typeof callback === 'function') {
            callback();
          }
        }
      }
    };

    TrelloModel.prototype.update = function () {
      const args = arguments.length > 0 ? [...arguments] : [];

      let opts, next;
      let params = {};
      if (_.isString(args[0])) {
        const key = args[0];
        const value = args[1];
        params[key] = value;
        if (args.length === 3) {
          next = args[2];
        } else {
          opts = args[2];
          next = args[3];
        }
      } else {
        params = args[0];
        if (args.length === 2) {
          next = args[1];
        } else {
          opts = args[1];
          next = args[2];
        }
      }
      if (!opts && !_.isFunction(next)) {
        opts = next;
        next = () => {};
      }
      if (!opts?.waitForServer) {
        this.set(params);
        if (this.typeName && this.id) {
          syncDeltaToCache(client, this.typeName, { id: this.id, ...params });
        }
      }
      if (opts?.traceId) {
        params.traceId = opts.traceId;
      }
      if (opts?.skipPersist) {
        next?.();
        return;
      }
      if (opts?.debounceSaveInterval) {
        if (!this.persistUpdateDebounced) {
          this.persistUpdateDebounced = _.debounce(
            this._persistUpdate,
            opts.debounceSaveInterval,
          );
        }
        return this.persistUpdateDebounced(params, next);
      } else {
        return this._persistUpdate(params, next);
      }
    };

    TrelloModel.prototype._persistUpdate = function (params, next) {
      const traceId = params.traceId ? params.traceId : '';
      delete params.traceId;

      if (this.typeName === 'Card' && this.getCardRole && this.getCardRole()) {
        const possibleCardRole = determinePossibleCardRole({
          name: this.get('name'),
          description: this.get('desc'),
          numAttachments: this.attachmentList.length,
          numLabels: this.get('idLabels').length,
          numMembers: this.get('idMembers').length,
          numChecklistItems: this.get('badges').checkItems,
          numCustomFieldItems: this.customFieldItemList.length,
          startDate: this.get('start'),
          dueDate: this.get('due'),
          cover: this.get('cover'),
        });

        // On update, we don't want to assign a new cardRole; we only
        // want to unset it if the card is now a "normal" card
        if (!possibleCardRole) {
          params.cardRole = possibleCardRole;
        }
      }

      return this.api(
        {
          type: 'put',
          data: params,
          traceId,
        },
        next,
      );
    };

    TrelloModel.prototype.addToSet = function () {
      let arg,
        attr,
        collectionName,
        delta,
        j,
        newValue,
        next,
        opts,
        ref1,
        traceId,
        value,
        waitForServer;
      (attr = arguments[0]),
        (value = arguments[1]),
        (arg =
          4 <= arguments.length
            ? slice.call(arguments, 2, (j = arguments.length - 1))
            : ((j = 2), [])),
        (next = arguments[j++]);
      opts = arg[0];
      if (
        opts /* eslint-disable-line eqeqeq */ == null &&
        !_.isFunction(next)
      ) {
        opts = next;
        next = () => {};
      }
      (ref1 = opts ?? {}),
        (traceId = ref1.traceId),
        (waitForServer = ref1.waitForServer),
        (collectionName = ref1.collectionName);
      // eslint-disable-next-line @typescript-eslint/no-this-alias
      const model = this;
      if (collectionName /* eslint-disable-line eqeqeq */ == null) {
        collectionName = attr;
      }
      if (!waitForServer) {
        newValue = _.uniq(model.get(attr) ?? []).concat(value);
        this.set(attr, newValue);
        if (this.typeName && this.id) {
          delta = {};
          delta[attr] = newValue;
          delta.id = this.id;
          syncDeltaToCache(client, this.typeName, delta);
        }
      }
      return this.api(
        {
          method: collectionName,
          data: {
            value: value,
          },
          traceId,
          success: ((_this) => (resp, next) => {
            const data = {};
            data[attr] = _.uniq(model.get(attr).concat(value));
            _this.modelCache.enqueueDelta(model, data);
            return typeof next === 'function' ? next(null, resp) : undefined;
          })(this),
        },
        next,
      );
    };

    TrelloModel.prototype.pull = function () {
      let arg,
        attr,
        collectionName,
        delta,
        j,
        newValue,
        next,
        opts,
        ref1,
        traceId,
        value,
        waitForServer;
      (attr = arguments[0]),
        (value = arguments[1]),
        (arg =
          4 <= arguments.length
            ? slice.call(arguments, 2, (j = arguments.length - 1))
            : ((j = 2), [])),
        (next = arguments[j++]);
      opts = arg[0];
      if (
        opts /* eslint-disable-line eqeqeq */ == null &&
        !_.isFunction(next)
      ) {
        opts = next;
        next = () => {};
      }
      (ref1 = opts ?? {}),
        (traceId = ref1.traceId),
        (waitForServer = ref1.waitForServer),
        (collectionName = ref1.collectionName);
      // eslint-disable-next-line @typescript-eslint/no-this-alias
      const model = this;
      if (collectionName /* eslint-disable-line eqeqeq */ == null) {
        collectionName = attr;
      }
      if (!waitForServer) {
        newValue = _.without(model.get(attr) ?? [], value);
        this.set(attr, newValue);
        if (this.typeName && this.id) {
          delta = {};
          delta[attr] = newValue;
          delta.id = this.id;
          syncDeltaToCache(client, this.typeName, delta);
        }
      }
      return this.api(
        {
          method: collectionName + '/' + value,
          type: 'delete',
          traceId,
          success: ((_this) => (resp, next) => {
            const data = {};
            data[attr] = _.without(model.get(attr), value);
            _this.modelCache.enqueueDelta(model, data);
            return typeof next === 'function' ? next(null, resp) : undefined;
          })(this),
        },
        next,
      );
    };

    TrelloModel.prototype.run = function (method, data, next) {
      return this.api(
        {
          method: method,
          data: data,
        },
        next,
      );
    };

    TrelloModel.prototype.api = function (arg, next = () => {}) {
      let data, datatype, method, success, type;
      (method = arg.method),
        (type = arg.type),
        (data = arg.data),
        (success = arg.success),
        (datatype = arg.datatype);
      // eslint-disable-next-line @typescript-eslint/no-this-alias
      const model = this;
      const headers = {};

      const traceId = arg.traceId;
      if (datatype /* eslint-disable-line eqeqeq */ == null) {
        datatype = '';
      }
      if (method /* eslint-disable-line eqeqeq */ == null) {
        method = '';
      }
      if (type /* eslint-disable-line eqeqeq */ == null) {
        type = 'post';
      }
      if (data /* eslint-disable-line eqeqeq */ == null) {
        data = {};
      }
      if (success /* eslint-disable-line eqeqeq */ == null) {
        success = ((_this) => (resp, next) => {
          let entry;
          if (resp.id === model.id) {
            _this.modelCache.enqueueDelta(model, resp);
          } else if (_.isArray(resp)) {
            entry = _.find(resp, (e) => e.id === model.id);
            if (entry /* eslint-disable-line eqeqeq */ != null) {
              _this.modelCache.enqueueDelta(model, entry);
            }
          }
          next(null, resp);
        })(this);
      }
      this.waitForId(
        this,
        ((_this) => () => {
          let url;
          url = _this.url();
          if (
            method /* eslint-disable-line eqeqeq */ != null &&
            method !== ''
          ) {
            url += '/' + method;
          }
          return Promise.using(_this.modelCache.getLock(), () =>
            _this._apiQueue.add(() => {
              return new Promise((resolve, reject) =>
                ApiAjax({
                  url: url,
                  type: type,
                  data: data,
                  datatype: datatype,
                  traceId,
                  headers,
                  success: function (data) {
                    resolve(Promise.fromNode((next) => success(data, next)));
                  },
                  error: function (arg1, textStatus, error, fxDefault) {
                    let responseText, status;
                    (status = arg1.status), (responseText = arg1.responseText);
                    error = ApiError.fromResponse(status, responseText);
                    if (
                      error instanceof ApiError.Server ||
                      error instanceof ApiError.NoResponse ||
                      error instanceof ApiError.PreconditionFailed
                    ) {
                      fxDefault();
                    }
                    reject(error);
                  },
                }),
              );
            }),
          )
            .nodeify(next)
            ['catch'](() => {})
            .done();
        })(this),
      );
      return this;
    };

    TrelloModel.prototype.toggle = function () {
      let add, arg, attr, j, next, value;
      (attr = arguments[0]),
        (value = arguments[1]),
        (add = arguments[2]),
        (arg =
          5 <= arguments.length
            ? slice.call(arguments, 3, (j = arguments.length - 1))
            : ((j = 3), [])),
        (next = arguments[j++]);
      const opts = arg[0];
      return this[add ? 'addToSet' : 'pull'](attr, value, opts, next);
    };

    TrelloModel.prototype.snoop = function (attr) {
      if (attr /* eslint-disable-line eqeqeq */ != null) {
        return new Hearsay.ContinuousSignal(
          ((_this) => (send) => {
            send(_this.get('attr'));
            const update = () => send(_this.get('attr'));
            _this.listenTo(_this, 'change:' + attr, update);
            return () => _this.stopListening(_this, 'change:' + attr, update);
          })(this),
        );
      } else {
        return new Hearsay.ContinuousSignal(
          ((_this) => (send) => {
            send(_this);
            const update = () => send(_this);
            _this.listenTo(_this, 'change', update);
            return () => _this.stopListening(_this, 'change', update);
          })(this),
        );
      }
    };

    TrelloModel.prototype.isVisibleAction = (action) => true;

    TrelloModel.prototype.getActions = function () {
      const modelsForFiltering =
        1 <= arguments.length ? slice.call(arguments, 0) : [];
      return this.modelCache
        .all('Action')
        .filter(
          ((_this) => (action) =>
            action.includesModel(_this) &&
            _.all(modelsForFiltering, (model) => action.includesModel(model)) &&
            _this.isVisibleAction(action))(this),
        );
    };

    return TrelloModel;
  })(Backbone.Model);

  _.extend(TrelloModel.prototype, SchedulingMixin);

  module.exports = TrelloModel;
}.call(this));
