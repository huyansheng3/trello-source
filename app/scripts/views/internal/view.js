/* eslint-disable
      no-prototype-builtins,
          eqeqeq,
        @typescript-eslint/no-use-before-define
*/
// Generated by CoffeeScript 1.12.7
/*
  Because of the way this file was decompiled, typescript cannot detect its type
  That is why we use `@ts-ignore` in every place we reference this.
  If you're here to convert it to a class, please make sure to clean all the related `@ts-ignore`s
*/
(function () {
  const extend = function (child, parent) {
      for (const key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  const $ = require('jquery');

  const Backbone = require('@trello/backbone');

  const Hearsay = require('hearsay');
  const PostRender = require('app/scripts/views/lib/post-render');
  const { SchedulingMixin } = require('app/scripts/lib/scheduling-mixin');

  const _ = require('underscore');

  const { l } = require('app/scripts/lib/localize');

  const { sendErrorEvent } = require('@trello/error-reporting');
  const { featureFlagClient } = require('@trello/feature-flag-client');
  const SubviewRemover = require('app/scripts/views/internal/subview-remover');

  const defaultRouter = require('app/src/router').defaultRouter;

  const VIGOR = {
    NONE: 0,
    SOME: 1,
    LOTS: 2,
  };

  const View = (function (superClass) {
    extend(View, superClass);

    function View(options) {
      this._subviews = {};
      this.modelCache = options != null ? options.modelCache : void 0;
      defaultRouter.updateSubscribers();
      View.__super__.constructor.apply(this, arguments);
    }

    View.prototype._rendered = false;

    View.VIGOR = VIGOR;

    View.prototype.vigor = VIGOR.LOTS;

    View.prototype.render = function () {
      const args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (this.renderOnce == null) {
        return this;
      }
      if (this._rendered) {
        switch (this.vigor) {
          case VIGOR.NONE:
            return this;
          case VIGOR.SOME:
            sendErrorEvent(
              Error('rendered more than once: ' + this.constructor.name),
            );
            return this;
          default:
            throw Error('You cannot render me more than once!');
        }
      }
      this._rendered = true;
      this.renderOnce.apply(this, args);
      return this;
    };

    View.prototype.renderIfNecessary = function () {
      if (!this.renderOnce || !this._rendered) {
        this.render();
      }
      return this;
    };

    View.prototype.getViewTitle = function () {
      let ref;
      if (this.viewTitleKey == null) {
        return '';
      }
      const key = _.result(this, 'viewTitleKey');
      const args =
        (ref = _.result(this, 'viewTitleArguments')) != null ? ref : {};
      return l(['view title', key], args);
    };

    View.prototype.subview = function (Type, model, opts, key) {
      if (opts == null) {
        opts = {};
      }
      if (key == null) {
        key = Type.prototype.uniqueId() + '_' + model.cid;
      }
      if (!(key in this._subviews)) {
        this._subviews[key] = new Type(
          _.extend(
            {
              model: model,
              modelCache: this.modelCache,
            },
            opts,
          ),
        );
      }
      return this._subviews[key];
    };

    View.prototype.existingSubview = function (Type, model, key) {
      if (key == null) {
        key = Type.prototype.uniqueId() + '_' + model.cid;
      }
      if (!(key in this._subviews)) {
        throw new Error('existingSubview called before subview was created');
      }
      return this._subviews[key];
    };

    View.prototype.existingSubviewOrUndefined = function (Type, model, key) {
      if (key == null) {
        key = Type.prototype.uniqueId() + '_' + model.cid;
      }
      return this._subviews[key];
    };

    View.prototype.collectionSubview = function (Type, collection, opts, key) {
      let base;
      if (opts == null) {
        opts = {};
      }
      if (key == null) {
        key = Type.prototype.uniqueId();
      }
      const subview =
        (base = this._subviews)[key] != null
          ? base[key]
          : (base[key] = new Type(
              _.extend(
                {
                  collection: collection,
                  modelCache: this.modelCache,
                },
                opts,
              ),
            ));
      if (opts.el != null && subview.el !== opts.el) {
        subview.setElement(opts.el);
      }
      return subview;
    };

    View.prototype.subviewsOfType = function (Type) {
      let key, subview;
      const ref = this._subviews;
      const results = [];
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        subview = ref[key];
        if (subview instanceof Type) {
          results.push(subview);
        }
      }
      return results;
    };

    View.prototype.deleteSubview = function (view, key) {
      if (key == null) {
        key = view.constructor.prototype.uniqueId() + '_' + view.model.cid;
      }
      if (view !== this._subviews[key]) {
        throw new Error('incorrect key for subview in deleteSubview');
      }
      view.remove();
      return delete this._subviews[key];
    };

    View.prototype.removeSubviews = function () {
      const subviews = _.values(this._subviews);
      this._subviews = {};
      SubviewRemover.enqueue(subviews);
    };

    View.prototype.deleteSubviewsOfType = function (Type) {
      let i, len, subview;
      const ref = this.subviewsOfType(Type);
      for (i = 0, len = ref.length; i < len; i++) {
        subview = ref[i];
        this.deleteSubview(subview);
      }
    };

    View.prototype.remove = function () {
      this.unsubscribe();
      this.stopUsing();
      this.removeSubviews();
      this.cancelScheduled();
      return View.__super__.remove.apply(this, arguments);
    };

    View.prototype.frameDebounce = function (fn, context) {
      let invoked;
      if (context == null) {
        context = this;
      }
      invoked = false;
      return function () {
        if (invoked) {
          return;
        }
        invoked = true;
        this.requestAnimationFrame(function () {
          invoked = false;
          fn.call(context);
        });
      };
    };

    View.prototype.makeDebouncedMethods = function () {
      let i, len, methodName;
      const methodNames = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      for (i = 0, len = methodNames.length; i < len; i++) {
        methodName = methodNames[i];
        this[methodName + 'Debounced'] = this.frameDebounce(this[methodName]);
      }
    };

    View.prototype.delegateEvents = function () {
      let key, view;
      const args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      View.__super__.delegateEvents.apply(this, args);
      const ref = this._subviews;
      for (key in ref) {
        view = ref[key];
        view.delegateEvents();
      }
    };

    View.prototype.undelegateEvents = function () {
      let key, view;
      View.__super__.undelegateEvents.apply(this, arguments);
      const ref = this._subviews;
      for (key in ref) {
        view = ref[key];
        view.undelegateEvents();
      }
    };

    View.prototype.appendSubview = function (subview, $el) {
      return this.appendSubviews([subview], $el);
    };

    View.prototype.appendSubviews = function (subviews, $el) {
      let i, len, subview;
      if ($el == null) {
        $el = this.$el;
      }
      const frag = document.createDocumentFragment();
      for (i = 0, len = subviews.length; i < len; i++) {
        subview = subviews[i];
        subview.delegateEvents();
        frag.appendChild(subview.render().el);
      }
      return $el.append(frag);
    };

    View.prototype.ensureSubview = function (subview, $el) {
      return this.ensureSubviews([subview], $el);
    };

    View.prototype.ensureSubviews = function (subviews, $el) {
      let el, found, i, index, j, k, key, len, len1, len2, ref, subview, view;
      if ($el == null) {
        $el = this.$el;
      }
      const elContainer = $el[0];
      const elContainerNodes = _.clone(elContainer.childNodes);
      for (index = i = 0, len = elContainerNodes.length; i < len; index = ++i) {
        el = elContainerNodes[index];
        if (
          _.find(subviews, function (s) {
            return s.el === el;
          })
        ) {
          continue;
        }
        found = false;
        ref = this._subviews;
        for (key in ref) {
          view = ref[key];
          if (!(view.el === el && !found)) {
            continue;
          }
          this.deleteSubview(view, key);
          found = true;
        }
        if (!found) {
          throw new Error(
            'Could not find view associated with element to remove',
          );
        }
      }
      for (j = 0, len1 = subviews.length; j < len1; j++) {
        subview = subviews[j];
        if (
          _.find(elContainerNodes, function (el) {
            return subview.el === el;
          })
        ) {
          continue;
        }
        subview.delegateEvents();
        subview.render();
      }
      for (index = k = 0, len2 = subviews.length; k < len2; index = ++k) {
        subview = subviews[index];
        if (subview.el === elContainer.childNodes[index]) {
          continue;
        }
        if (index === 0) {
          $(elContainer).prepend(subview.el);
        } else {
          $(subviews[index - 1].el).after(subview.el);
        }
      }
    };

    View.prototype.uniqueId = function () {
      if (!this.hasOwnProperty('_uniqueId')) {
        this._uniqueId = _.uniqueId('view');
      }
      return this._uniqueId;
    };

    View.prototype.whenIdle = function (name, callback) {
      if (featureFlagClient.get('fep.cancel-post-render-callbacks', false)) {
        // Use the scheduler for the callback so it gets cancelled
        // if the view has been removed
        PostRender.enqueue(name, this.callback(callback));
      } else {
        PostRender.enqueue(...arguments);
      }
    };

    return View;
  })(Backbone.View);

  _.extend(View.prototype, SchedulingMixin, Hearsay.mixin);

  module.exports = View;
}.call(this));
